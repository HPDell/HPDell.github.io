{"meta":{"title":"HPDell 的个人博客","subtitle":"我们在小孩和大人的转角盖一座城堡","description":"HPDell 的博客","author":"hpdell","url":"http://hpdell.github.io"},"pages":[{"title":"关于我","date":"2019-01-22T22:20:00.000Z","updated":"2019-01-22T14:33:19.170Z","comments":true,"path":"about/index.html","permalink":"http://hpdell.github.io/about/index.html","excerpt":"","text":"关于我其实没什么好说的。 欢迎在此留言。"},{"title":"分类","date":"2017-11-29T11:01:13.000Z","updated":"2019-01-22T14:33:19.186Z","comments":false,"path":"categories/index.html","permalink":"http://hpdell.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-12-04T22:29:30.000Z","updated":"2019-01-22T14:33:19.186Z","comments":false,"path":"tags/index.html","permalink":"http://hpdell.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《逃避虽可耻但有用》观后感","slug":"nigeru-wa-haji-daga-yaku-ni-tatsu","date":"2019-01-22T14:09:39.000Z","updated":"2019-01-22T14:33:19.114Z","comments":true,"path":"随笔/nigeru-wa-haji-daga-yaku-ni-tatsu/","link":"","permalink":"http://hpdell.github.io/随笔/nigeru-wa-haji-daga-yaku-ni-tatsu/","excerpt":"“在匈牙利有这么一句谚语，逃避可耻却有用。选择后退不也很好吗，即使逃避很可耻，但更重要的是活下去。”","text":"“在匈牙利有这么一句谚语，逃避可耻却有用。选择后退不也很好吗，即使逃避很可耻，但更重要的是活下去。” 很早就被安利了这部剧，最近看完了。不是觉得新垣结衣好看才觉得这部剧好看，否则早就吹爆这部剧了。 这部剧刻画了一个极端的程序员的形象，并一点一点描写这样的程序员在面对生活上的改变。 同时也刻画了一个女权的家庭主妇形象，并一步一步寻找对家庭主妇价值，提出对待家庭主妇的生产力问题的思考。 新垣结衣给你们（手动滑稽），我最关注的还是这个“程序员”。 无论从哪个角度来说，新垣结衣饰演的森山实栗都是这部剧的主角，星野源所饰演的津崎平匡的性格变化只是本剧想要传达的次要思想。 一开始，对津崎平匡面对森山实栗的无动于衷，只是一句“你比我想象中的要年轻”，到后来在实栗面前选择逃避，最后大胆接受实栗， 这样的转变似乎恰好契合了人们对于程序员这一类人群的印象，但不是每个人都有一个美貌勤劳的实栗小姐被老丈人亲自送上门来。 面对程序，一眼就找到问题在哪里的平匡，在面对内心萌动的爱情时，仿佛湮没在巨大的海洋，找不到方向。 其实不光是程序员，其他行业的男生并不是不会遇到这样的问题。 电影《建筑学概论》中，李帝勋饰演的李胜民在建筑学概论课程上遇见了裴秀智饰演的杨瑞妍，内心知道自己喜欢她，但是不敢表白。 和杨瑞妍不断相处中已经赢得了杨瑞妍的好感，却因为与杨瑞妍和高富帅室友之间产生了误会，痛下狠心和杨瑞妍绝交。 杨瑞妍在约定的第一场雪的时候来到他们曾经约好的地点，李胜民却躺在自己家里默默流泪。 其实是谁让他真的能够决心不再见杨瑞妍？不是别人，不是杨瑞妍，也不是高富帅，是他自卑的自己而已。 动画片《四月是你的谎言》中，原本弹得一手好钢琴却因为母亲去世而无法演奏岗前地有马公生，在和同伴的一次出游中，结识了宫园薰。 在两人不断地相处中，渐渐意识到自己喜欢宫园薰，但是他觉得宫园薰是喜欢阿渡，于是自己说服了自己放弃了，也不敢去表达关心。 但是终于最后明白了宫园薰喜欢的是他，也逐渐承认了自己喜欢薰。可惜喜欢没来得及说出口，宫园薰就离开了人世。 从宫园薰留下的遗书中，他知道了原来从一开始薰就是想要接近自己，可惜没有理由，只好借阿渡接近自己。 电影《壁花少年》中，罗根·勒曼饰演的“壁花少年”查理和艾玛·沃特森饰演的珊是好朋友。查理喜欢珊，但是他觉得珊喜欢别人，自己也是壁花一个，就算了。 有个女生喜欢他，他们也在一起了。但是在真心话大冒险中，他亲了珊，导致他们几个好朋友之间的关系一度紧张。 后来他们要升学之前，在查理家里，珊找到了他，对他说：“你不能只顾别人而不顾自己，还把这视为爱，我不要有人迷恋我，我要别人喜欢真正的我。” 听了这句话，查理才抛开自己的自卑，和珊亲吻。 平匡幸运的是，“国民老婆”新垣结衣（实栗）是在他家做保洁的，还比平匡更敢于表达，还对帅哥追求无动于衷。 而“国民初恋”裴秀智（杨瑞妍）只是李胜民隔壁学校的一个女生，谁都可以去撩她，胜民不过是这些学生中普通地不能再普通地一个而已。 查理和珊本来就是朋友，还帮珊讲题，珊也没有只把查理当成真人点读机。 有马公生和他们相比，本应该是最幸运的，却因为病魔的折磨，变成了最不幸的。 “逃避可耻但有用。”平匡、胜民、公生、查理四人，其实都只是在逃避而已。为什么人要选择逃避？因为那是自己不擅长的地方。 平匡在同时遇到Bug的时候主动说“我来试一下”； 胜民自己悄悄设计了瑞妍幻想的未来的家； 公生虽然在弹琴的时候听不到声音了但还是坚持练习，最终站在比赛舞台上； 查理在辅导珊学习给她讲题的时候并没有退却。 这些他们擅长的事，他们会逃避吗？ 面对自己不擅长又不得不做的事，逃避虽可耻但有用。但是最终，你会发现，逃避并没有让问题消失，也不能让自己得到快乐，甚至麻烦越来越大。 就像平匡躺在床上的那种痛苦，幻想身边是实栗的痛苦，觉得实栗不会喜欢自己的痛苦。而实栗就要离开他时，他才明白，逃避的好处是一时的，坏处是一世的。 只有自己主动面对，才能得到自己想要的结果。 倒过来，对于森山实栗来说，这也是一样的。森山实栗擅长做家务，但不擅长找工作。当她把家务当成工作，当然干的很开心。但是这又何尝不是一种逃避？ 随着平匡被解雇，没有了那么好的收入来源，家务在当今社会不能给家庭带来直接的收入。所以其实问题并没有解决，实栗还是需要一份工作。 她以最低工资标准帮好朋友田中安惠和邻居办商业街，才是她直面人生困难的正确解决之道。 另外说一下，以雇佣关系看待家庭主妇的事，平匡已经给出了错误的点。而他们认为的共同经营关系，其实也不符合家庭主妇情况， 就是因为家庭主妇做家务并不能带来直接收入，仅仅是减少了支出。我觉得除非社会为家庭主妇提供补贴，才能实现实栗所理想的情况。 除了男女主，这部剧中的很多人都在逃避。土屋百合面对风见凉太的逃避，沼田赖纲面对自己同性恋男友的逃避等等。 但大家都在商业街活动中，放弃了逃避，最终都收获了好的结果。 逃避虽可耻但有用，但有用是一时的，人也不能可耻一辈子。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://hpdell.github.io/categories/随笔/"}],"tags":[{"name":"影评","slug":"影评","permalink":"http://hpdell.github.io/tags/影评/"}]},{"title":"Vue 中使用 Video.js 播放 RTMP 视频","slug":"vue-vidoejs-rtmp","date":"2019-01-19T19:14:04.000Z","updated":"2019-01-22T14:33:19.158Z","comments":true,"path":"编程/vue-vidoejs-rtmp/","link":"","permalink":"http://hpdell.github.io/编程/vue-vidoejs-rtmp/","excerpt":"香港卫视有直播的 RTMP 流，本文简述了使用 Vue 技术播放 RTMP 流媒体的方法。","text":"香港卫视有直播的 RTMP 流，本文简述了使用 Vue 技术播放 RTMP 流媒体的方法。 在网页上播放视频或者直播流，比较常用的视频流有很多。可以分为几类技术： HTTP 系列。直播采用的是 ogg 格式的流媒体； Apple 系列。直播采用的是 HLS 格式的流媒体； Flash 系列。直播采用的是 RTMP 格式的流媒体。 Video.js 库已经将常见的视频流进行了封装，并扩展了 HTML 的视频控件的能力。 因此我们主要使用 Video.js 作为基础进行开发。 Vue-Video-Player 的改造在 Vue 中使用 Video.js 库的时候，常用的库就是 Vue-Video-Player 这个库。 这个库将 Video.js 封装为 Vue 组件，在 Vue 项目中直接引用即可。 但是这个库在播放 RTMP 格式视频流的时候，会出现问题！我们需要对其进行改造。 其实这个库最核心的源码就是一个名为 player.vue 的组件。其他文件不过是作为 Vue 插件的必要代码。 因此，我们可以直接将这个组件复制到我们的工程中，以普通组件的方式引入即可。 然后对其进行改造。改造方法如下 123import _videojs from 'video.js'const videojs = window.videojs || _videojs+ import \"videojs-flash\" 这个库无法播放 RTMP 的根本原因尚不清楚，不过从这个改造方法来看，可能是由于作用域的问题， 导致在外部引入的 videojs-flash 模块无法在这个组件中加载，因此需要将这个模块在组件中引入。 然后运行即可。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;h1&gt;RTMP Video&lt;/h1&gt; &lt;video-player :options=&quot;playerOptions&quot; :playsinline=&quot;true&quot; @statechanged=&quot;playerStateChanged($event)&quot;&gt;&lt;/video-player&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import VideoPlayer from &quot;./player.vue&quot;export default &#123; components: &#123; &quot;video-player&quot;: VideoPlayer &#125;, data () &#123; return &#123; playerOptions: &#123; sources: [&#123; type: &quot;rtmp/flv&quot;, src: &quot;rtmp://live.hkstv.hk.lxdns.com/live/hks2&quot; &#125;], techOrder: [&apos;flash&apos;], autoplay: true, controls: true, flash: &#123; swf: &quot;static/video-js.swf&quot; &#125;, height: &quot;320&quot; &#125; &#125; &#125;, methods: &#123; playerStateChanged (state) &#123; console.log(state) &#125; &#125;, mounted() &#123; &#125;&#125;&lt;/script&gt; 在 Electron 中播放在 Electron 中播放，需要加载 Flash。加载的方法也很简单，将下面代码加入创建窗口之前 12345let flashPath = app.getPath('pepperFlashSystemPlugin');console.log(flashPath);app.commandLine.appendSwitch(\"ppapi-flash-path\", flashPath);app.commandLine.appendSwitch('ppapi-flash-version', '29.0.0.013'); // 可以不要 然后打开 Electron 插件的功能 1234567mainWindow = new BrowserWindow(&#123; height: 563, useContentSize: true,+ webPreferences: &#123;+ plugins: true+ &#125;,&#125;) 然后把 videojs-flash 中提供的 video-js.swf 文件放到 statics 文件夹下即可。 这是我们在 Electron 中使用的效果。 打包模式下的问题上述 Electron 应用在打包后，就无法播放 RTMP 视频了。为什么呢？ Electron 应用一旦打包，所有资源的加载都是以 file:// 协议进行加载的，这时 Flash 被禁用了。 这是官方的解释。但是其实我试过，直接用 embed 标签从 static 文件夹中加载 swf 文件是可以的。 但是为什么 video-js.swf 就加载不出来，原因就不得而知了。 如果想要加载视频，可以采取将 Electron 编译好的 HTML 文件放到服务器上，如 nginx 。 通过服务器加载 Electron 应用内的页面。 官方给出的解决方案是，使用 nw-flash-trust 库，信任 Flash 。 但是我至今也没有试出来到底怎么使用这个库。 经过测试，我实验出了一种打包方法，可以摆脱单独的服务器。原理是采用内置服务器，最简单的方法是用 Express。 在应用程序的主进程中创建一个 Express 服务器，只需要设置静态文件中间件，即可通过服务器加载页面。 在主进程的 index.js 文件中添加如下函数 12345function localServer() &#123; let server = express(); server.use(express.static(__dirname)); server.listen(8888);&#125; 然后做如下修改： 123456import express from \"express\"let mainWindowconst winURL = process.env.NODE_ENV === 'development' ? `http://localhost:9082`- : `file://$&#123;__dirname&#125;/index.html`+ : `http://localhost:8888/index.html` 1234567891011121314151617181920212223242526function createWindow () &#123; /** * Initial window options */ mainWindow = new BrowserWindow(&#123; height: 563, useContentSize: true, width: 1000, frame: true, webPreferences: &#123; plugins: true &#125; &#125;) mainWindow.loadURL(winURL) mainWindow.webContents.openDevTools() mainWindow.on('closed', () =&gt; &#123; mainWindow = null &#125;)+ if (process.env.NODE_ENV === \"production\") &#123;+ localServer();+ &#125;&#125; 然后就可以愉快地在本地播放 RTMP 视频啦。 这是本地播放视频的效果。 （没想到香港卫视晚上竟然在播《虹猫蓝兔七侠传》系列，童年心痛的回忆啊，央视播了一半被举报然后停播了） 在网页中播放由于现在主流浏览器都抛弃了 Flash ，默认关闭 Flash 。而 Video.js 是不会去请求 Flash 权限的。 因此我们需要一个 embed 标签加载一个 swf 文件，通过点击这个标签获取 Flash 权限。 当然，在实际生产中，后续如何处理，就看大家怎么搞了。 这是我们在网页上获取 Flash 权限之前的效果： 点击 flash 文件，获取权限，效果如下：","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://hpdell.github.io/tags/Vue/"},{"name":"网页开发","slug":"网页开发","permalink":"http://hpdell.github.io/tags/网页开发/"}]},{"title":"武汉大学《硕士英语》课视听文件字幕","slug":"english-postgraduates-subtitles","date":"2019-01-12T13:28:47.000Z","updated":"2019-01-22T14:33:19.086Z","comments":true,"path":"其他/english-postgraduates-subtitles/","link":"","permalink":"http://hpdell.github.io/其他/english-postgraduates-subtitles/","excerpt":"《硕士英语》主要有 TED 演讲，影视作品，以及采访等。 TED 演讲除了 Do Schools Kill Creativity 采用翻译稿制作中英字幕外， 其他的 TED 演讲以及记录片 An Inconvenient Truth 均采用 TED2Srt 给出的字幕文件制作成中英字幕。 影视作品有《刮痧》和《心灵捕手》，视频自带字幕。 其他视频博主使用软件对视听文件进行了语音识别，并制作成了英文字幕。 其中， 60 Second Adventures in Economics 网上有带中英字幕的视频，可以直接看网上的。","text":"《硕士英语》主要有 TED 演讲，影视作品，以及采访等。 TED 演讲除了 Do Schools Kill Creativity 采用翻译稿制作中英字幕外， 其他的 TED 演讲以及记录片 An Inconvenient Truth 均采用 TED2Srt 给出的字幕文件制作成中英字幕。 影视作品有《刮痧》和《心灵捕手》，视频自带字幕。 其他视频博主使用软件对视听文件进行了语音识别，并制作成了英文字幕。 其中， 60 Second Adventures in Economics 网上有带中英字幕的视频，可以直接看网上的。 下面是这些字幕文件的链接 单元 文件 第一单元 Understanding.the.rise.of.China 第二单元 An.Inconvenient.Truth(1) An.Inconvenient.Truth(2) global.warming How.the.ghost.map.helped.end.a.killer.disease Healthy.Foods 第三单元 60.Second.Adventures.in.Economics (no1) 60.Second.Adventures.in.Economics (no2) 60.Second.Adventures.in.Economics (no3) Grit.The.power.of.passion.and.perseverance 第四单元 JamesCameron 第五单元 CynthiaSchneider SirKenRobinson","categories":[{"name":"其他","slug":"其他","permalink":"http://hpdell.github.io/categories/其他/"}],"tags":[{"name":"课程","slug":"课程","permalink":"http://hpdell.github.io/tags/课程/"}]},{"title":"利用 Travis-CI 持续集成 LaTeX 文档","slug":"latex-travis","date":"2018-11-30T21:40:27.000Z","updated":"2019-01-22T14:33:19.114Z","comments":true,"path":"编程/latex-travis/","link":"","permalink":"http://hpdell.github.io/编程/latex-travis/","excerpt":"最近写了一个整理《应用数理统计》的文档，想要通过 Travis-CI 持续集成到 GitHub 上。 然而踩了非常多的坑。下面我就再整理一下，这个配置的过程。","text":"最近写了一个整理《应用数理统计》的文档，想要通过 Travis-CI 持续集成到 GitHub 上。 然而踩了非常多的坑。下面我就再整理一下，这个配置的过程。 配置过程 在 GitHub 上发布打包好的 TexLive 2018 利用打包好的 TexLive 2018 编译文档并上传 GitHub Release 在 GitHub 上发布打包好的 TexLive 2018可以直接 Fork GitHub 上的仓库 holgern/travis-texlive ， 然后 Travis 就开始持续集成的过程。 但是要在 Travis 里面配置一个 GitHub Personal Access Token ， 将生成的 Token 配置到 Travis 的设置中。 在 Travis 中看到成功运行后（注意可能要非常长的时间，将近1小时），可以将仓库克隆下来，打 Tag 了。 打了 Tag ，上传到 GitHub 仓库，就可以让 Travis 持续集成发布到 GitHub Release 中。 注意：这个过程可以不用，如果你只用了所有 TexLive 自带的包，那可以直接使用 holgern/travis-texlive 的打包结果。但是如果你要安装非自带的包，那么就要先打包最新的 TexLive ，否则是无法安装的。 利用打包好的 TexLive 2018 编译文档并上传 GitHub Release编译文档的 Travis 配置文件如下： 123456789101112131415161718192021222324252627282930language: bashsudo: requireddist: trustybefore_install: - curl -L https://github.com/HPDell/travis-texlive/releases/download/2018-11-30_02/texlive.tar.xz | tar -JxC ~ - PATH=$HOME/texlive/bin/x86_64-linux:$PATH - wget https://github.com/alif-type/xits/releases/download/v1.200/XITS-1.200.zip -O XITS.zip - unzip XITS.zip - sudo mkdir -p /usr/share/fonts/opentype/ - sudo mv ./XITS-1.200/XITS*.otf /usr/share/fonts/opentype/ - sudo mkfontscale - sudo mkfontdir - sudo fc-cache -fv - sudo pip install Pygmentsbranches: only: - /^v[\\d.]+\\d$/script: - xelatex -synctex=1 -interaction=nonstopmode -shell-escape MathematicalStatistics.tex - xelatex -synctex=1 -interaction=nonstopmode -shell-escape MathematicalStatistics.tex - xelatex -synctex=1 -interaction=nonstopmode -shell-escape MathematicalStatistics.texdeploy: provider: releases api_key: secure: $GITHUB_TOKEN file: - MathematicalStatistics.pdf skip_cleanup: true on: tags: true before_install 部分进行了以下几个步骤： 下载了打包的 TexLive 2018 ，并配置环境变量 下载了使用的 XITS 字体包并安装字体 安装了 Pygments 包以使用 minted 宏包 branchs 使用正则表达式配置了只有以 v[\\d.]+\\d 即形如 v1.0.0 的分支才进行持续集成。 script 里面就是 LaTeX 编译的流程。 deploy 里面设置部署的方式。$GITHUB_TOKEN 就代表了 Travis CI 配置的参数。 skip_cleanup: true 跳过 Travis 清理的过程，才能上传文件。 on: tags: true 表示只有在打了 tag 的提交上才进行部署。 最终部署的结果如下，还是非常满意的。欢迎大家下载我的 《应用数理统计复习整理》。 持续集成真的好方便。","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"http://hpdell.github.io/tags/LaTeX/"},{"name":"travis","slug":"travis","permalink":"http://hpdell.github.io/tags/travis/"}]},{"title":"开个全局视角再看《哈利·波特》——阿兹卡班的囚徒","slug":"Harry-Potter-Prisoner-of-Azkaban","date":"2018-11-03T22:21:30.000Z","updated":"2019-01-22T14:33:18.994Z","comments":true,"path":"随笔/Harry-Potter-Prisoner-of-Azkaban/","link":"","permalink":"http://hpdell.github.io/随笔/Harry-Potter-Prisoner-of-Azkaban/","excerpt":"最近《神奇动物：格林德沃之罪》要上映了，于是想重温一下之前的《哈利·波特》系列。 在看完全书以及整个系列电影，并看了很多番外资料后，再来看这这个系列。 之前看的时候，很多精力都花到记名字、记脸、理解情节上去了， 而且其他方面包括感情啥的啥也不懂，遗漏了很多细节。 现在再来看，有个上帝视角的加持，感觉完全不一样啊。 不过原著其实也已经忘了很多了，电影倒很多还记得，所以算是个假的上帝视角吧。","text":"最近《神奇动物：格林德沃之罪》要上映了，于是想重温一下之前的《哈利·波特》系列。 在看完全书以及整个系列电影，并看了很多番外资料后，再来看这这个系列。 之前看的时候，很多精力都花到记名字、记脸、理解情节上去了， 而且其他方面包括感情啥的啥也不懂，遗漏了很多细节。 现在再来看，有个上帝视角的加持，感觉完全不一样啊。 不过原著其实也已经忘了很多了，电影倒很多还记得，所以算是个假的上帝视角吧。 电影的序幕，这里哈利在读《终极咒语》一书，书里面好像讲用的是手电筒，不过这个处理感觉还是挺好的，这样毕竟拿个手电筒不会惊动德斯礼先生对吧。 不得不说，弗农·德斯礼和玛姬·德斯礼两个演员确实很像姐弟了，剧组找人费心了。 后面玛姬变成气球，据说演员在片场穿了一天的一种膨胀服，才拍出了这样的效果。 穿膨胀服其实非常难受，佩服这种敬业的演员！ 哈利在街头的时候，出来了一只黑狗，感觉可能就是小天狼星·布莱克？ 好像就是在《阿兹卡班的囚徒》开头，赫敏买了克鲁克山， 但克鲁克山一个猫灵天天追着小矮星彼得变的老鼠咬， 我也已经不太记得克鲁克山为啥要咬小矮星？难道是因为它觉得这个老鼠不寻常？ 邓布利多这番话，可能是在暗示对抗摄魂怪的方法——点亮心灯， 也需要守护神咒点亮另一盏灯。 罗恩吃了糖然后发出狮吼，我觉得如果这里埋下伏笔， 后面哈利在引诱变了身的卢平教授的时候，吃一颗狼叫的糖， 就更有趣了。不过可能显得有点刻意。 之前有个同学发哈利波特相关的说说时，发了这个茶渣。我当时忘记了。 现在再看这个茶渣，神似一条黑色的狗，那当然是暗示小天狼星的到来。 只不过没人知道小天狼星会变成狗。 电影里面没提，但好像书里面说的是，德拉科向他父亲告状，然后海格被停课了？ 这段戏肯定是艾伦·里克曼真人扮演的，在一群孩子们面前。 相信对于艾伦·里克曼来说，穿着滑稽的衣服，听着孩子们的哄堂大笑， 也确实是一件有点难为人的事。 谨以此段致敬里克曼先生！ ) 卢平教授以为哈利会让博格特变成伏地魔，挡在了他的面前，结果博格特变成了满月。 这里也是明确暗示卢平是狼人，最害怕的是满月。 斯内普当然是担心卢平会放小天狼星进来，在知道了卢平、小天狼星、斯内普的恩怨， 以及邓布利多与他们的关系，这点确实很好理解了。 这把雨伞后面看好像其实是摄魂怪？ 其实我很好奇，福吉部长、麦格教授、罗斯墨塔夫人为什么是这三个人凑到一起 讨论小天狼星的问题？ 另外前段事件看到麦格教授的扮演者玛姬·史密斯已经84岁高龄了， 身材、样貌已经被衰老摧残，同样表示敬意！ 作为当年的哈赫党，看到这个镜头真的是太感动了。 是赫敏摸到了隐身的哈利，而不是罗恩，也不是金妮。 这是哈利第一次成功使用守护神咒击退一个“摄魂怪”。 他之前用的记忆是第一次骑飞天扫帚，那是一种从未体验过的自由飞翔的快乐。 但这种快乐不够强烈，因为飞多了也就不觉得是快乐了。 后面他选择了在厄里斯魔镜里面看到的他父母的事作为记忆， 因为他从小父母双亡，渴望见到父母，这种记忆才是最快乐、最持久的， 什么时候想到都会是快乐的。 那么问题来了，如果是我，我会选择什么记忆呢？什么是我内心真正的快乐呢？ 第一次看电影的时候根本不会去注意活点地图上到底写的是谁的名字， 以至于其实这段看的时候是懵的，之注意到了后面哈利看到小矮星彼得在走廊里走 但是却没有人的问题。这其实也暗示了小矮星不是以人的形象出现的。 他告诉了卢平，卢平才会发现小矮星没死的问题。 水晶球真的变成水晶的时候，出现了小天狼星的头像。 赫敏这两张痛扁马尔福的镜头真的是帅爆了。哈利、罗恩也只是口头上怼马尔福， 赫敏动手了！太帅了。感觉这一学年的赫敏在三个人中起到了领导者的作用， 不仅动脑了，而且动手。在赫敏的带动下，哈利后来才勇敢地面对一群摄魂怪。 其实按照这个视角，哈利三人是看不到巴克比克被处死了的。这是正为后面埋下伏笔。 哈利和赫敏拯救了巴克比克，刽子手其实只剁了一块南瓜。 最令我感动的是这里，斯内普教授说“复仇的滋味真好”。斯内普为什么要复仇？ 大家认为小天狼星干的事情就是出卖了詹姆·波特和莉莉·波特，致使他们被杀。 斯内普一定是要为这个复仇。那么斯内普讨厌詹姆·波特，肯定不是为好友报仇。 那是为什么？一定是为莉莉·波特报仇！也就暗示了斯内普其实是爱着莉莉的。 这样看斯内普对莉莉的爱更真实了。 据说卢平的扮演者加里·奥德曼小时候就梦想自己变成狼人，没想到在电影里实现了。 这里不禁联想起《死亡圣器》的《银色的牝鹿》一章。 我把这张银色的牝鹿设置为了手机封面。这里是哈利的守护神，是只雄鹿。 他爸爸的守护神也是雄鹿。 这句话感觉来的恰到好处，让长期处于紧张状态的观众一下子轻松了下来。 赫敏毕竟还是个女生，虽然书里面描写她头发总是乱蓬蓬的， （《火焰杯》里参加完舞会的第二天她的头发就依然是乱蓬蓬的， 她说每天那样弄太麻烦了），但男生都会注意自己的发型，何况一个女生？ 这个情节不知道是不是电影原创的，但是感觉非常巧妙。 妥妥的哈赫党福利。发现赫敏转身寻求安慰的时候喜欢往右边转， 这不之前往右边转就转到罗恩肩上了（手动滑稽）。 赫敏前面才说了她不喜欢飞的感觉，镜头一转就坐了前面？ 哈利难道真的不懂得怜香惜玉？或者说这里是导演的失误？","categories":[{"name":"随笔","slug":"随笔","permalink":"http://hpdell.github.io/categories/随笔/"}],"tags":[{"name":"影评","slug":"影评","permalink":"http://hpdell.github.io/tags/影评/"},{"name":"哈利波特","slug":"哈利波特","permalink":"http://hpdell.github.io/tags/哈利波特/"}]},{"title":"在 Windows 10 Linux 子系统中安装 xfce 桌面","slug":"wsl-xfce","date":"2018-10-20T14:20:52.000Z","updated":"2019-01-22T14:33:19.166Z","comments":true,"path":"其他/wsl-xfce/","link":"","permalink":"http://hpdell.github.io/其他/wsl-xfce/","excerpt":"早就想捣腾 Linux 子系统里面的桌面了，之前由于姿势水平不够，没弄成。 之前试着装 Windows/Ubuntu 双系统，不仅系统没装成，由于由于用傲梅分区助手还把文件弄坏了很多， 实名大写 DISS 傲梅分区助手。最近 Windows 商店的 X410 打折，￥298 变成了 ￥33，太划算了。 于是买了下来，接着捣鼓 Xfce 桌面。","text":"早就想捣腾 Linux 子系统里面的桌面了，之前由于姿势水平不够，没弄成。 之前试着装 Windows/Ubuntu 双系统，不仅系统没装成，由于由于用傲梅分区助手还把文件弄坏了很多， 实名大写 DISS 傲梅分区助手。最近 Windows 商店的 X410 打折，￥298 变成了 ￥33，太划算了。 于是买了下来，接着捣鼓 Xfce 桌面。 安装 WSL 和 X410安装了 Linux 子系统之后，通过 apt 安装 xfce 桌面。 12sudo apt update &amp;&amp; sudo apt -y upgradesudo apt install xfce4 xfce4-terminal 如果源很慢，那么建议更换源。我更换了各种国内源，发现还是清华的源好用。 然后安装 X410 ，据说 Xming 也可以，但是我没试。 安装应用图标的解释， X410 代表 XServer for Windows 10，确实还是很好用的。 然后编写一个 Windows 批处理脚本（.bat 文件），这样编写代码： 12start /B x410.exe /desktopbash.exe -c \"if [ -z \\\"$(pidof xfce4-session)\\\" ]; then export DISPLAY=127.0.0.1:0.0; xfce4-session; pkill '(gpg|ssh)-agent'; fi;\" 这里面 bash.exe 就是你装的 Linux 子系统命令行启动的程序。 -c 参数表示执行后面的代码。 常用功能配置这里写出来的都是 Ubuntu Bionic 的配置方法，其他版本的 Ubuntu 不保证可以运行。 安装中文和字体安装中文语言包和字体管理器 12sudo apt-get install language-pack-zh-hanssudo apt-get install font-manager 然后把你需要的字体复制到 /usr/share/fonts/windows/ 目录，最后一层目录可以自己起名字。 然后配置语言环境 12sudo fc-cache -fvsudo dpkg-reconfigure locales 配置时选择 zh_CN.UTF-8 ，可以同时选 en_US.UTF-8 。 配置完成后，可以注销，重新登陆。然后界面会变成中文的。可以在 设置-外观-字体-默认字体 中选择默认字体。 我下载了开源的思源黑体，将其配置为默认字体。同时也需要设置窗口管理器的默认字体。 如果是用思源黑体，一定要选择那个中文名字的思源黑体，不然中文字体还是宋体。 浏览器xfce 默认没有装任何浏览器，需要自己装。最简单的是装 Firefox ，直接 apt 安装即可。 安装 Google 浏览器的话，比较麻烦一点 1234sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -sudo apt-get updatesudo apt-get install google-chrome-stable Firefox 在 Perference 里面可以设置语言和默认字体。 输入法国内常用的还是搜狗拼音，虽然我也已经很多年没用搜狗拼音了。装搜狗拼音比较麻烦，需要先安装 fcitx ， 如果你没有安装或者按照其他教程写的把 fcitx 卸载了的话。 1sudo apt install fcitx 如果出现了错误，安装 apt 的提示来，可能会提示你要修复依赖，那么就是使用命令 1sudo apt-get -f install 然后下载搜狗拼音的 deb 文件，是用下面的命令安装 1dpkg -i sogoupinyin_2.2.0.0108_amd64.deb 然后运行 fcitx ，配置 fcitx ，添加搜狗拼音输入法。 这时候可能还不能是用搜狗拼音输入法，如果你能使用，那恭喜你中大奖了。 启动脚本修改经过多方查找资料，我终于知道我搜狗拼音不能使用的原因了。把启动脚本需要修改成这样 12start /B x410.exe /desktopbash.exe -c \"if [ -z \\\"$(pidof xfce4-session)\\\" ]; then export DISPLAY=127.0.0.1:0.0; export LC_CTYPE=zh_CN.UTF-8; export XMODIFIERS=@im=fcitx; export GTK_IM_MODULE=fcitx; export QT_IM_MODULE=fcitx; xfce4-session; pkill '(gpg|ssh)-agent'; fi;\" 这样启动了之后就直接可以是用搜狗拼音输入法了。 主题修改自带主题看起来，嗯……一言难尽。那么通过下面的方式换个主题。 123sudo add-apt-repository -y ppa:tista/adaptasudo apt updatesudo apt install adapta-gtk-theme 然后安装 Roboto 和 Noto 字体，可以装可以不装把。 12sudo apt install fonts-robotosudo apt install fonts-noto 然后将 外观 和 窗口管理器 中的主题换为 Adapta 主题。这个主题和 VSCode 还真的是挺配的。 还可以安装一个图标包 1234sudo add-apt-repository -y ppa:papirus/papirussudo apt updatesudo apt install papirus-icon-themesudo add-apt-repository --remove ppa:papirus/papirus Tilix 终端这个终端的功能很强大，可以做终端复用等功能。看个人喜好了。 1sudo apt install tilix","categories":[{"name":"其他","slug":"其他","permalink":"http://hpdell.github.io/categories/其他/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://hpdell.github.io/tags/Linux/"}]},{"title":"常用代码","slug":"usually-use-code","date":"2018-10-14T16:55:26.000Z","updated":"2019-01-22T14:33:19.158Z","comments":true,"path":"编程/usually-use-code/","link":"","permalink":"http://hpdell.github.io/编程/usually-use-code/","excerpt":"记录一些常用的命令行代码。","text":"记录一些常用的命令行代码。 Git 命令查看纯提交信息日志1git log &lt;tag1&gt;..&lt;tag2&gt; --pretty=\"%s\" --no-merges 其中 &lt;tag1&gt;..&lt;tag2&gt; 可以用于筛选日志，换成分支名称也一样。两个 . 不能省略。 查看上一个tag到当前tag之间的日志1git log `git tag -l | sed -e '1&#123;$q;&#125;' -e '$!&#123;h;d;&#125;' -e x`..`git tag -l | sed -n '$p'` --pretty=\"%s\" --no-merges ffmpeg 命令嵌入字幕1ffmpeg -i &lt;input&gt; -vf scale=&lt;width&gt;:&lt;height&gt;,pad=&lt;width&gt;:&lt;height&gt;:&lt;xpos&gt;:&lt;ypos&gt;,subtitles=&lt;ass&gt; &lt;output&gt; 常用直播流地址 名称 地址 香港卫视 rtmp://live.hkstv.hk.lxdns.com/live/hks2 香港卫视 http://live.hkstv.hk.lxdns.com/live/hks/playlist.m3u8 CCTV1高清 http://ivi.bupt.edu.cn/hls/cctv1hd.m3u8 CCTV3高清 http://ivi.bupt.edu.cn/hls/cctv3hd.m3u8 CCTV5高清 http://ivi.bupt.edu.cn/hls/cctv5hd.m3u8 CCTV5+高清 http://ivi.bupt.edu.cn/hls/cctv5phd.m3u8 CCTV6高清 http://ivi.bupt.edu.cn/hls/cctv6hd.m3u8 PowerShell批量 Excel 转 csv12345678910$ExcelWB = new-object -comobject excel.applicationGet-ChildItem -Path c:\\folder -Filter \"*.xls\" | ForEach-Object&#123; $Workbook = $ExcelWB.Workbooks.Open($_.Fullname) $newName = ($_.Fullname).Replace($_.Extension,\".csv\") $Workbook.SaveAs($newName,6) $Workbook.Close($false)&#125;$ExcelWB.Quit()","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[]},{"title":"Python 多进程编程","slug":"py-multiprocess","date":"2018-07-09T18:53:07.000Z","updated":"2019-01-22T14:33:19.158Z","comments":true,"path":"编程/py-multiprocess/","link":"","permalink":"http://hpdell.github.io/编程/py-multiprocess/","excerpt":"Python 在处理大数据的时候，启用多进程是有效提高计算效率的手段。 Python 已经提供了非常好用的 multiprocess 包来支持多进程编程， 但是在多进程编程时仍然会遇到一些难以处理的问题，需要一些技巧来解决。","text":"Python 在处理大数据的时候，启用多进程是有效提高计算效率的手段。 Python 已经提供了非常好用的 multiprocess 包来支持多进程编程， 但是在多进程编程时仍然会遇到一些难以处理的问题，需要一些技巧来解决。 目录： Python 多进程对效率的提升 Python 开启多进程 创建 Process 对象 构造参数 属性 方法 调用示例 将进程定义为类 进程池（Pool） 进程池构造 进程池方法 进程池调用示例 多进程共享资源 锁 互斥锁（Lock） 可重入锁（RLock） 条件锁（Condition) 信号量（Semaphore） 共享变量 multiprocess 包内置类型 通过 Manager 创建共享变量 进程间通信 通过事件（Event）通信 通过队列（Queue）通信 通过管道（Pipe）通信 其他 tqdm 多进度条 Windows 上 Lock 的问题 Python 多进程对效率的提升一篇《Python 中单线程、多线程和多进程的效率对比实验》的文章中提到： Python是运行在解释器中的语言，有一个全局锁（GIL）， 在使用多进程(Thread)的情况下，不能发挥多核的优势。 而使用多进程(Multiprocess)，则可以发挥多核的优势真正地提高效率。 文章中对 Python 在多线程、多进程的效率进行了对比： 操作类型 CPU 密集型 IO 密集型 网络请求密集型 线性操作 94.91824996469 22.46199995279 7.3296000004 多线程操作 101.1700000762 24.8605000973 0.5053332647 多进程操作 53.8899999857 12.7840000391 0.5045000315 可见： 多线程操作只在网络请求密集型操作中具有非常明显的优势，其开销小于多进程，可用于网络爬虫。 多进程操作在各种操作中都有效率提升，在 IO 密集型操作中的优势更大。 最近在处理一套出租车数据，出租车数据量非常大，自己搭建数据库， 查询效率非常低。因此采用 Python 脚本进行处理， Python 开启多进程Python 中的 multiprocess 包提供了多进程支持。可以使用三种方法来创建进程。 创建 Process 对象最简单的开启 Python 进程的方法，是直接构造 multiprocess.Process 对象 123from multiprocess import Processprocess = Process() 构造参数Process 对象在构造时主要接收三个参数： target：进程调用的函数； args：进程调用函数时给函数传递的参数，为一个元组； name：别名。 属性Process 的类型有以下属性： daemon：当这个属性设置为 True 时，子进程会随着主进程的结束而结束。否则，主进程结束后，子进程依然会继续进行； exitcode：进程在运行时为 None 、如果为 –N ，表示被信号 N 结束； name pid authkey 方法Process 有如下方法： start()：调用 start() 函数时，子进程开始执行，主进程继续执行。 join()：“阻塞当前进程，直到调用 join 方法的那个进程执行完，再继续执行当前进程。” run()：当构造时如果没有制定 target 参数，那么 start() 方法默认执行 run() 函数。 is_alive()：判断当前进程是否活动。 调用示例12345678910111213141516171819202122from multiprocess import Processimport osimport mathdef work_fun(work_list): passdef distrib_works(work_list, process_num): group_length = math.ceil(len(filename_list) / process_num) return [work_list[(i*group_length):((i+1)*group_length)] for i in range(process_num)]work_list = os.listdir(\"../data\")process_num = 4group = distrib_works(work_list, process_num)process_list = [Process(target=work_fun, args=(g,)) for g in group_list]for p in process_list: p.daemon = True p.start()for p in process_list: p.join() 将进程定义为类利用 Python 面向对象的特性，我们可以创建一个类，继承 Process 类， 将一些数据直接在构造的时候保存下来，可以无需在调用的时候传入。 例如，当我们在多进程程序中使用 tqdm 库显示进度条时，会用到其 position 参数来指定当前进度条在控制台中显示的位置，这个参数的值，我们可以直接保存在进程类中， 无需调用的时候再传入。 将进程定义为类的方法如下： 12345678910111213from multiprocess import Processclass MyProcess(Process): position = 0 works = None def __init__(self, position, works) Process.__init__(self) self.position = poisition self.works = works def run(): pass 如果在构造函数中，调用的 Process 的构造函数没有指定 target， 进程同样默认执行 不带参数的 run 函数，即使你的 run 函数定义了形参！ 在创建进程时，只需要将原来调用的 Process 的构造函数，改为调用 MyProcess 的构造函数即可。 这种创建进程方式的实例如下： 12345678910111213141516171819202122232425262728293031from multiprocess import Process, Lockdef distrib_works(work_list: List[str], process_num) -&gt; List[List[str]]: group_length = math.ceil(len(work_list) / process_num) return [g for g in [work_list[(i*group_length):((i+1)*group_length)] for i in range(process_num)] if len(g) &gt; 0]class FindTargetTaxiProcess(multiprocessing.Process): def __init__(self, input_files, index, lock, log_file): multiprocessing.Process.__init__(self, target=find_target, args=(lock, log_file)) self.input_files = input_files self.index = index def find_target(self, lock, log_file): for filename in self.input_files: with open(filename) as in_file: for row in tqdm(in_file, ncols=80, position=self.index): cells = row.split(\",\") if int(cells[0]) == 11865: print(row)if __name__ == '__main__': LOG_FILE = r\"E:\\出租车点\\上下车点\\scripts\\data\\find_error.log\" lock = multiprocessing.Lock() # ROOT_DIR = \"../data/201502/temp\" ROOT_DIR = r\"E:\\出租车点\\201502\\RawCSV\" INPUT_FILES = [os.path.join(ROOT_DIR, f) for f in os.listdir(ROOT_DIR)] GROUP_LIST = distrib_works(INPUT_FILES, 4) PROCESS_LIST = [FineTargetTaxiProcess(element, i, lock) for i, element in enumerate(GROUP_LIST)] for process in PROCESS_LIST: process.start() 这种定义为类的方式有一个好处，在用 VSCode 调试的时候，在子进程中打断点是无效的。 如果用这种方式，可以将调用的 start() 函数改为 run() 或其他实际进程执行的函数， 这样就可以调试进程内部了。当解决了 Bug 后，就可以换回 start() 函数并行执行。 进程池（Pool）可以发现，上面两种创建进程的方式，都是用到了一个 distrib_works() 函数来分配各个进程的任务。 这一过程可以被一个叫做进程池的类型代替。 进程池构造构造进程池的方法非常简单，导入 Pool 之后，直接构造 Pool 对象。 构造时可以指定最多的进程数量，默认是 CPU 核心数。 123from multiprocess import Poolp = Pool(process=6) 进程池方法Pool 类型主要有以下方法： apply_async() 和 apply()：这两个函数都是让进程池开始执行任务，apply_async() 是非阻塞的（主进程继续执行），apply() 是阻塞的（主进程等待子进程执行完成后继续执行）。 close()：关闭进程池，不再接收新任务。 join()：主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用。 进程池调用示例将上面一段使用 FindTargetTaxiProcess 类编写的代码用 Pool 重写： 123456789101112131415161718192021from multiprocess import Process, Pool, Lockdef find_target(in_file, lock, log_file): with open(filename) as in_file: for row in tqdm(in_file, ncols=80, position=self.index): cells = row.split(\",\") if int(cells[0]) == 11865: with lock: with open(log_file, mode=\"a\") as log: print(row, file=log)if __name__ == '__main__': LOCK = multiprocessing.Lock() LOG_FILE = r\"E:\\出租车点\\上下车点\\scripts\\data\\find_error.log\" ROOT_DIR = r\"E:\\出租车点\\201502\\RawCSV\" INPUT_FILES = [os.path.join(ROOT_DIR, f) for f in os.listdir(ROOT_DIR)] POOL = Pool(process=6) for f in INPUT_FILES: POOL.apply_async(find_target, (f, LOCK, LOG_FILE)) POOL.close() POOL.join() 多进程共享资源当我们把多个任务分解到 $n$ 个进程上执行时，这 $n$ 个进程往往会存在某种共享的资源， 如共享一个控制台、文件系统、列表或字典。这里存在两个问题： 当多个进程同时访问这些资源时，就会产生冲突。例如，两个进程同时对控制台输出文本，写入的结果可以错综复杂，并不是两段文本的顺序组合。 各个进程有自己的内存空间，变量无法共享。例如，当想要利用多个进程操作主进程的一个列表时，各个进程操作结束后，主进程仍然是原来的状态。 这两个问题的解决，前者靠“锁”机制，后者靠“共享变量”机制。 锁对于冲突的情况，当使用 tqdm 显示多个进度条时比较明显。在 Windows 上，由于 “tqdm 无法获取默认锁”，因此控制台输出会比较乱，下面是一段程序在 Windows 上运行的效果： 123456789101112λ python3 find_errors.pyProcess 0: 0it [00:00, ?it/s]Process 1: 0it [00:00, ?it/s]Process 0: 273516it [00:00, 523719.79it/s]Process 0: 995883it [00:01, 510379.67it/s]Process 0: 1107387it [00:02, 510326.10it/s]Process 0: 1224813it [00:02, 512761.81it/s]Process 0: 3483799it [00:06, 539191.83it/s]Process 1: 3683852it [00:06, 571536.15it/s]Process 0: 3550015it [00:06, 540296.03it/s]Process 0: 3615558it [00:06, 540947.45it/s]Process 0: 3742521it [00:06, 542112.37it/s] 而在 Linux 系统中的运行结果是 1234Process 0: 2045720it [00:03, 647073.52it/s]Process 1: 2092184it [00:03, 661530.01it/s]Process 2: 2065411it [00:03, 652446.31it/s]Process 3: 2093610it [00:03, 661782.04it/s] 可见在访问共享资源的时候，加锁是非常有必要的。 互斥锁（Lock）Lock 属于“互斥锁”，即保证在任一时刻，只能有一个线程访问该对象。 通过 Lock 类型创建互斥锁后，将其传递到子进程内部，即可在子进程中使用。 使用 Lock 时，可以使用 with 语句加锁， with 语句块执行完成后自动解锁； 也可以通过其 acquire() 函数来加锁，使用 release() 函数解锁。 使用 with 语句进行加锁的示例代码如下： 123456789def run(self): for filename in self.input_files: with open(filename, encoding=\"GB2312\") as in_file: for row in tqdm(in_file): cells = row.split(\",\") if int(cells[0]) == 11865: with self.lock: with open(TARGET_TAXI_FILE, mode=\"a\") as log: print(row, file=log) 这段代码在 Windows 上运行时，子进程内部的 lock 和 主进程传递进去的 lock 的 id 值不相同。 但是在 Linux 系统上时相同的。因此 Windows 上这段代码有可能会出错。 不过当文件被一个进程打开时，是无法被另一个进程打开的，因此这段程序的结果倒没出什么错。 可重入锁（RLock）互斥锁可以解决简单的避免资源冲突的问题，但当一个线程加锁后仍需要再次访问共享资源时， 就形成了嵌套锁，而使用互斥锁时就形成了“死锁”问题。这时我们需要使用 RLock 类型， 即“可重入锁”。 死锁的含义是：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象， 若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 避免死锁主要方法是正确有序的分配资源。 multiprocess 中的 RLock 类型与 Lock 类型的区别在于： RLock允许在同一线程中被多次申请。而 Lock 却不允许这种情况。 因此，如果使用 RLock ，那么 acquire() 和 release() 必须成对出现， 调用了几次 acquire()，就需要调用几次 release()。 条件锁（Condition)条件同步机制是指：线程 $B$ 等待特定条件 $C$ ，而另一个线程 $A$ 发出特定条件满足的信号 $C$ 。 $B$ 在收到信号 $C$ 时，继续执行。 可以通过“生产者-消费者”模型来理解这一过程。 生产者获取锁，生产一个随机整数，通知消费者并释放锁。 消费者获取锁，如果有整数则消耗一个整数并释放锁，如果没有就等待生产者继续生产。 示例代码如下（参考《Python 线程同步机制》并进行修改）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import multiprocessclass Producer(multiprocessing.Process): def __init__(self, productList, condition): multiprocessing.Process.__init__(self) self.productList = productList # type: List self.condition = condition # type: multiprocess.Condition def run(self): while True: product = random.randint(0, 100) with self.condition: print(\"条件锁：被 生产者 获取\") self.productList.append(product) print(f\"生产者：产生了 &#123;product&#125;。\") print(\"生产者：唤醒消费者线程\") self.condition.notify() print(\"条件锁：被 生产者 释放\") time.sleep(1)class Customer(multiprocessing.Process): def __init__(self, productList, condition): multiprocessing.Process.__init__(self) self.productList = productList # type: List self.condition = condition # type: multiprocess.Condition def run(self): while True: with self.condition: print(\"条件锁：被 消费者 获取\") while True: if self.productList: product = self.productList.pop() print(f\"消费者：消费了 &#123;product&#125;\") break print(\"消费者：等待生产者\") self.condition.wait() print(\"条件锁：被 消费者 释放\")def main(): manager = multiprocessing.Manager() productList = manager.list() condition = multiprocessing.Condition() process_producer = Producer(productList, condition) process_customer = Customer(productList, condition) process_producer.start() process_customer.start() process_producer.join() process_customer.join()if __name__ == '__main__': main() 运行的部分结果是： 12345678910111213141516171819202122232425条件锁：被 生产者 获取生产者：产生了 47。生产者：唤醒消费者线程条件锁：被 生产者 释放条件锁：被 消费者 获取消费者：消费了 47条件锁：被 消费者 释放条件锁：被 消费者 获取消费者：等待生产者条件锁：被 生产者 获取生产者：产生了 100。生产者：唤醒消费者线程条件锁：被 生产者 释放消费者：消费了 100条件锁：被 消费者 释放条件锁：被 消费者 获取消费者：等待生产者条件锁：被 生产者 获取生产者：产生了 95。生产者：唤醒消费者线程条件锁：被 生产者 释放消费者：消费了 95条件锁：被 消费者 释放条件锁：被 消费者 获取消费者：等待生产者 信号量（Semaphore）信号量是一个非负整数，所有通过它的进程都会将该整数减一， 当该整数值为零时，所有试图通过它的进程都将处于等待状态。 123456789101112131415from multiprocessing import Process, current_process, Semaphoreimport timedef worker(s, i): s.acquire() print(current_process().name + \"acquire\"); time.sleep(i) print(current_process().name + \"release\\n\"); s.release()if __name__ == \"__main__\": s = Semaphore(2) for i in range(5): p = Process(target = worker, args=(s, i*2)) p.start() 共享变量在多进程中，是无法直接使用全局变量作为共享变量的，因为不同进程具有不同的内存空间。 但是，共享变量也是不能避免的。Python 中也提供了一些创建共享变量的方法。 Multiprocess 包内置类型 通过 Manager 创建共享变量 multiprocess 包内置类型multiprocess 包提供了两种类型的共享变量： Value(typecode_or_type, *args, lock=True)：表示一个值类型变量。 Array(typecode_or_type, size_or_initializer, *, lock=True)：表示一个数组。这种创建数组的方式能力比较有限，它不支持除了 C 数据类型以外的类型。 typecode_or_type 描述了元素的类型，可取值是： typecode type ‘c’ ctypes.c_char ‘u’ ctypes.c_wchar ‘b’ ctypes.c_byte ‘B’ ctypes.c_ubyte ‘h’ ctypes.c_short ‘H’ ctypes.c_ushort ‘i’ ctypes.c_int ‘I’ ctypes.c_uint ‘l’ ctypes.c_long ‘L’ ctypes.c_ulong ‘f’ ctypes.c_float ‘d’ ctypes.c_doubl 创建后，只要将这些变量传递给子进程即可。 通过 Manager 创建共享变量Manager() 返回的 manager 对象提供一个服务进程，使得其他进程可以通过代理的方式操作 Python 对象。 Manager 支持 list、dict 等多种数据类型。 （多进程multiprocess） 把之前的共享变量的代码中，共享的变量由 list 改为 Manager 对象创建的 list，可以得到正确结果。 1234567891011121314151617from multiprocessing import Process, Lock, Managerimport timedef work(lock, var, index): with lock: var.append(index) print(f\"Process &#123;index&#125; apped &#123;index&#125;\")if __name__ == '__main__': var = Manager().list() lock = Lock() process_list = [Process(target=work, args=(lock, var, i)) for i in range(8)] for p in process_list: p.start() for p in process_list: p.join() print(var) 进程间通信进程间通信，可以起到共享变量的效果，也可以起到锁的效果。 进程间通信的方式有三种： 事件（Event） 队列（Queue） 管道（Pipe） 通过事件（Event）通信Event 是同步通信的方式，有些类似于条件锁。由于是它是同步的，而且不能传递数据。 因此这里就不仔细研究 Event 的作用。 这个例子示例了主进程与子进程之间通过 Event 进行通信的方法。 12345678910111213141516171819202122import multiprocessingimport timedef wait_for_event(e): print(\"wait_for_event: starting\") e.wait() print(\"wairt_for_event: e.is_set()-&gt;\" + str(e.is_set()))def wait_for_event_timeout(e, t): print(\"wait_for_event_timeout:starting\") e.wait(t) print(\"wait_for_event_timeout:e.is_set-&gt;\" + str(e.is_set()))if __name__ == \"__main__\": e = multiprocessing.Event() w1 = multiprocessing.Process(target=wait_for_event, args=(e,)) w2 = multiprocessing.Process(target=wait_for_event_timeout, args=(e, 6)) w1.start() w2.start() time.sleep(10) print(\"main: event setting\") e.set() print(\"main: event is set\") 通过队列（Queue）通信Queue 是多进程安全的队列，可以使用 Queue 实现多进程之间的数据传递。 Queue 有两个方法： put()：将数据插入队列中。 get()：从队列读取并且删除一个元素。 这两个方法都有两个参数：blocked, timeout， 控制队满和队空两种情况： put：当队满时，如果 blocked=True ，那么会阻塞 timeout 指定的时间，直到队列有空间。如果超时，或 blocked=False ，则抛出 Queue.Full 异常。 get：当队满时，如果 blocked=True ，那么会阻塞 timeout 指定的时间，直到队列有元素。如果超时，或 blocked=False ，则抛出 Queue.Empty 异常。 调用实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class FineTargetTaxiProcess(mp.Process): ''' 处理进程：多进程方式处理文件，结果全部传递给打印进程。 ''' def __init__(self, input_files, index, queue): mp.Process.__init__(self, target=self.pick, args=(queue,)) self.input_files = input_files self.index = index self.lock = lock def pick(self, queue): for filename in tqdm(self.input_files, ncols=80, position=self.index, desc=f\"Process &#123;self.index&#125;\"): with open(filename, encoding=\"GB2312\") as in_file: for row in in_file: cells = row.split(\",\") if int(cells[0]) == 11865: try: queue.put(\",\".join(cells), block=False) except: print(\"Queue full\")class PrinterProcess(mp.Process): ''' 打印进程：维持对输出文件的打开状态，打印数据。 可避免频繁打开、关闭结果文件造成的系统开销， 但是引入了消息传递的开销。 ''' def __init__(self, output_file, log, queue): mp.Process.__init__(self, target=self.write, args=(queue,)) self.output_file = output_file self.log_file = log def write(self, queue): with open(self.output_file, mode=\"w\", newline=\"\\n\") as printer, open(self.log_file, mode=\"w\") as log: while True: try: row = queue.get(block=True, timeout=1) print(row, file=printer) except: print(\"Queue empty\", file=log)if __name__ == '__main__': lock = mp.Lock() ROOT_DIR = r\"/mnt/e/出租车点/201502/RawCSV\" INPUT_FILES = [os.path.join(ROOT_DIR, f) for f in os.listdir(ROOT_DIR)] GROUP_LIST = distrib_works(INPUT_FILES, 6) QUEUE = mp.Queue() PROCESS_LIST = [FineTargetTaxiProcess(element, i, QUEUE) for i, element in enumerate(GROUP_LIST)] PRINTER_PROCESS = PrinterProcess(\"./data/usequeue.txt\", \"./data/usequeue.log\", QUEUE) for process in PROCESS_LIST: process.daemon = True process.start() PRINTER_PROCESS.daemon = True PRINTER_PROCESS.start() for p in PROCESS_LIST: p.join() 通过管道（Pipe）通信Pipe 是一个可以双向通信的对象，返回 (conn1, conn2)， 代表一个管道的两个端， conn1 只负责接受消息， conn2 只负责发送消息。 如果设置了 duplex=True ，那么这个管道是全双工模式， conn1 和 conn2 均可收发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class FineTargetTaxiProcess(mp.Process): ''' 处理进程：多进程方式处理文件，结果全部传递给打印进程。 ''' def __init__(self, input_files, index, pipe): mp.Process.__init__(self, target=self.pick, args=(pipe,)) self.input_files = input_files self.index = index self.lock = lock def pick(self, pipe): for filename in tqdm(self.input_files, ncols=80, position=self.index, desc=f\"Process &#123;self.index&#125;\"): with open(filename, encoding=\"GB2312\") as in_file: for row in in_file: cells = row.split(\",\") if int(cells[0]) == 11865: try: pipe.send(\",\".join(cells)) except e as Exception: print(\"Pipe send error\")class PrinterProcess(mp.Process): ''' 打印进程：维持对输出文件的打开状态，打印数据。 可避免频繁打开、关闭结果文件造成的系统开销， 但是引入了消息传递的开销。 ''' def __init__(self, output_file, log, pipe): mp.Process.__init__(self, target=self.write, args=(pipe,)) self.output_file = output_file self.log_file = log def write(self, pipe): with open(self.output_file, mode=\"w\", newline=\"\\n\") as printer, open(self.log_file, mode=\"w\") as log: while True: try: row = pipe.recv() print(row, file=printer) except e as Exception: print(\"Pipe read error\", file=log)if __name__ == '__main__': lock = mp.Lock() # ROOT_DIR = \"../data/201502/temp\" ROOT_DIR = r\"/mnt/e/出租车点/201502/RawCSV\" INPUT_FILES = [os.path.join(ROOT_DIR, f) for f in os.listdir(ROOT_DIR)] GROUP_LIST = distrib_works(INPUT_FILES, 6) (RECEIVER, SENDER) = mp.Pipe() PROCESS_LIST = [FineTargetTaxiProcess(element, i, SENDER) for i, element in enumerate(GROUP_LIST)] PRINTER_PROCESS = PrinterProcess(\"./data/usepipe.txt\", \"./data/usepipe.log\", RECEIVER) for process in PROCESS_LIST: process.daemon = True process.start() PRINTER_PROCESS.daemon = True PRINTER_PROCESS.start() for p in PROCESS_LIST: p.join() 其他tqdm 多进度条是一个快速，可扩展的 Python 进度条，可以在 Python 长循环中添加一个进度提示信息， 用户只需要封装任意的迭代器 tqdm(iterator) 。 这里有一些参数： ncols：整个进度条（包括条以及其他文字）的宽度。最好设置一个小于控制台总宽的值。 mininterval：进度条更新的最小间隔。默认为 0.1。 position：进度条的位置，从0开始。对不同的 tqdm 对象设置不同的 position，可以在控制台的不同位置显示出来，适用于多进程与多线程。 由于 Windows 上多进程时 tqdm 无法获取默认的锁，所以会出现进度条错乱。在 Linux 上是没有问题的。 Windows 上 Lock 的问题其实每次传入子进程函数内部的 Lock，在各个进程中的 id 都不一样。在 Linux 下没有这个问题。 这往往会导致一些程序在 Windows 上不正确。 因此，在 Windows 上最好少用 Lock，多采用消息传递或共享变量的方式设计程序。","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://hpdell.github.io/tags/Python/"}]},{"title":"WPF 使用消息插销（Plug）机制在多个组件之间传递消息","slug":"wpf-plug","date":"2018-03-20T16:04:57.000Z","updated":"2019-01-22T14:33:19.166Z","comments":true,"path":"编程/wpf-plug/","link":"","permalink":"http://hpdell.github.io/编程/wpf-plug/","excerpt":"WPF 这个框架，有一些比较令人头疼的问题，组件之间的消息传递就是其中的一个。 《WPF 编程宝典》中提到了“命令”的方法，具有一些优越性。 除此之外，笔者在实践中设计了一种 Plug 机制，实现组件间的通讯。","text":"WPF 这个框架，有一些比较令人头疼的问题，组件之间的消息传递就是其中的一个。 《WPF 编程宝典》中提到了“命令”的方法，具有一些优越性。 除此之外，笔者在实践中设计了一种 Plug 机制，实现组件间的通讯。 组件间通讯往往一些组件之间需要互相通讯，但是互相通讯的组件不一定互相可见。 比如在一个页面上，有一个列表 List 和一个地图 Map，列表与地图要实现联动。 由于在逻辑上，列表时主窗口的组件，地图也是主窗口的组件，因此他们互不可见。 （List 无法直接调用 Map 的方法或订阅 Map 的事件，Map 也是如此）。 这种问题会非常常见。 既然是通讯，就一定有发送方（Sender）和接收方（Receiver）； 既然不可见，就一定要有中间件（MiddleWare），来传递消息。 对于中间件，其必须被二者可见，或可见二者 （比如 MiddleWare 可见 Sender，Receiver 可见 MiddleWare， 即 MiddleWare 可以调用 Sender 的方法或订阅 Sender 的事件， MiddleWare 可以调用 Receiver 的方法或订阅 Receiver 的事件）。 《WPF 编程宝典》中给出的“命令模型”，用在解决这个问题时，属于 “MiddleWare 可见二者”。本文所提出的消息插销机制，属于 “MiddleWare 被二者可见”。 命令模型命令模型用于解决这个问题的过程是：需要发送方抛出命令，中间件接收命令， 并指挥接收方执行相应操作。 WPF 中定义了 ICommand 接口，来描述命令。所有的命令都继承自该接口。 但是一般使用实现了该接口的两个类 RoutedCommand 和 RoutedUICommand。 这两个类都实现了命令事件的冒泡，功能也差不多，只是 RoutedUICommand 包含了一个字符串。 发送命令之前，需要有一个已经实例化的命令对象，可以直接使用 RoutedCommand。 比如定义一个静态类，里面包含所有需要用到的命令对象。 12345678910111213public class FireHandleCommans&#123; static RoutedCommand _showPinMarkersCommand = new RoutedCommand(); /// &lt;summary&gt; /// 显示大头针命令 /// &lt;/summary&gt; static public RoutedCommand ShowPinMarkersCommand &#123; get =&gt; _showPinMarkersCommand; set =&gt; _showPinMarkersCommand = value; &#125;&#125; 这里定义好了之后，在需要抛出命令的地方使用 Execute() 方法： 1234UIControlCommands.ShowPinMarkersCommand.Execute( new Tuple&lt;IEnumerable&lt;IDataObjectBaseViewModel&gt;, IEnumerable&lt;IDataObjectBaseViewModel&gt;&gt;( ItemData, DataItemListView.ItemsSource.Cast&lt;IDataObjectBaseViewModel&gt;()), Application.Current.MainWindow); 在主窗口中（或发送方与接收方共同的父控件）接收此命令： 123&lt;Window.CommandBindings&gt; &lt;CommandBinding Command=\"&#123;x:Static UICommands:UIControlCommands.ShowPinMarkersCommand&#125;\" Executed=\"ListPageChangedCommandBinding_Executed\" /&gt;&lt;/Window.CommandBindings&gt; 然后在 ListPageChangedCommandBinding_Executed() 事件响应函数中 指挥接收方进行操作： 1234567891011121314private void ListPageChangedCommandBinding_Executed(object sender, ExecutedRoutedEventArgs e)&#123; if (e.Parameter is IEnumerable&lt;IDataObjectBaseViewModel&gt;) &#123; List&lt;IDataObjectBaseViewModel&gt; listItems = new List&lt;IDataObjectBaseViewModel&gt;(e.Parameter as IEnumerable&lt;IDataObjectBaseViewModel&gt;); List&lt;PointLatLng&gt; listPoints = new List&lt;PointLatLng&gt;(); // 在地图上添加大头针 listItems.ForEach((item) =&gt; &#123; listPoints.Add(new PointLatLng(item.Data.GPS_Y, item.Data.GPS_X)); &#125;); mapView.AddPinMarker(listPoints); &#125;&#125; 整个过程就是这样。 这个过程有个问题： 命令的参数没有显式指明类型。编程时往往会出错； 依赖公有父控件进行调度，但是有时候这本不是父控件的本职工作。 但是这种方法也有一些好处，由于命令是冒泡的，可以在不同的 UI 层级上做不同的操作。 理论上是这样。但是我从来没有成功过。 消息插销机制消息插销机制模仿了 WPF 命令模型的设计，设计了一个 IPlug 的接口， 和 PlugReceiveMessageDelegate 的委托。 IPlug 接口包含一个发送方方法，和一个接收方事件。 这个委托和接口中的方法采用相同的参数列表。具体实现如下： 12345678910111213141516171819202122/// &lt;summary&gt;/// 插销接收方委托/// &lt;/summary&gt;/// &lt;typeparam name=\"PlugArgs\"&gt;&lt;/typeparam&gt;/// &lt;param name=\"sender\"&gt;&lt;/param&gt;/// &lt;param name=\"args\"&gt;&lt;/param&gt;public delegate void PlugReceiveMessageDelegate&lt;PlugArgs&gt;(object sender, PlugArgs args);interface IPlug&lt;PlugArgs&gt;&#123; /// &lt;summary&gt; /// 调用方方法 /// &lt;/summary&gt; /// &lt;param name=\"sender\"&gt;&lt;/param&gt; /// &lt;param name=\"args\"&gt;&lt;/param&gt; void PlugSendMessage(object sender, PlugArgs args); /// &lt;summary&gt; /// 接收方事件 /// &lt;/summary&gt; event PlugReceiveMessageDelegate&lt;PlugArgs&gt; PlugReceiveMessageEvent;&#125; 我们当然是不可以直接使用这个接口的，需要定义类实现此接口，比如： 1234567891011121314151617181920212223242526272829public class ResizePinMarkerEventArgs&#123; int _pinMarkerIndex; public ResizePinMarkerEventArgs(int index) &#123; PinMarkerIndex = index; &#125; public int PinMarkerIndex &#123; get =&gt; _pinMarkerIndex; set =&gt; _pinMarkerIndex = value; &#125;&#125;public class EnlargePinMarkerPlug : IPlug&lt;ResizePinMarkerEventArgs&gt;&#123; /// &lt;summary&gt; /// 大头针变大接收方事件 /// &lt;/summary&gt; public event PlugReceiveMessageDelegate&lt;ResizePinMarkerEventArgs&gt; PlugReceiveMessageEvent; /// &lt;summary&gt; /// 大头针变大调用方方法 /// &lt;/summary&gt; /// &lt;param name=\"index\"&gt;&lt;/param&gt; public void PlugSendMessage(object sender, ResizePinMarkerEventArgs e) &#123; Console.WriteLine(\"Mouse Enter: \" + e.PinMarkerIndex); PlugReceiveMessageEvent?.Invoke(sender, e); &#125;&#125; 然后需要实例化此类，在一个静态类中加入静态属性： 123456789101112static public class Bolt&#123; /// &lt;summary&gt; /// 大头针变大插销 /// &lt;/summary&gt; public static EnlargePinMarkerPlug EnlargePinMarker &#123; get; internal set; &#125; static Bolt() &#123; EnlargePinMarker = new EnlargePinMarkerPlug(); &#125;&#125; 发送方在要发送消息的地方调用消息插销的发送方方法： 12345678910111213/// &lt;summary&gt;/// 鼠标移出列表项/// &lt;/summary&gt;/// &lt;param name=\"sender\"&gt;&lt;/param&gt;/// &lt;param name=\"e\"&gt;&lt;/param&gt;private void ListBoxItem_MouseLeave(object sender, MouseEventArgs e)&#123; if (e.OriginalSource is ListBoxItem) &#123; ListBoxItem item = e.OriginalSource as ListBoxItem; Plug.Bolt.MinifyPinMarker.PlugSendMessage(item, new Plug.EventArgs.ResizePinMarkerEventArgs((item.DataContext as IDataObjectBaseViewModel).Indicator)); &#125;&#125; 接收方订阅该插销的事件，即可接收消息了。 这种方法解决了命令模型的几个不方便的地方，但是同样也失去了命令模型的优势。 如果要在不同地方相应同一个消息插销，那就只能在不同地方分别订阅接收方事件了。","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"http://hpdell.github.io/tags/WPF/"},{"name":"C#","slug":"C","permalink":"http://hpdell.github.io/tags/C/"}]},{"title":"文书生成模块文档","slug":"hbh-java-poi-doc","date":"2018-03-19T20:11:12.000Z","updated":"2019-01-22T14:33:19.086Z","comments":true,"path":"编程/hbh-java-poi-doc/","link":"","permalink":"http://hpdell.github.io/编程/hbh-java-poi-doc/","excerpt":"这是一个使用 Apache POI 开源库进行文书模板生成的模块。","text":"这是一个使用 Apache POI 开源库进行文书模板生成的模块。 Word 模板键设置需要修改 Word 文档，使其成为一个模板，才能使用这个包。 模板中需要动态添加的字段或表格，使用 ${key} 代替，。 其中，key 可以替换为自己的字段，key 称为“模板键”。 为了提高开发效率，\b对模板键的设置做如下约定： \b单字段（DocElementField）使用 ${EL_} \b开头的模板键（如${EL_recorder}） 表格（DocTableField）使用 ${TB_} \b开头的模板键（如${TB_indicators}） 这样做的目的是，可以让一个人去做\b Word 模板，另一个人\b去针对每个 Word 文书制作生成器（DocGenerator）。 \b\b\b示例： \b\b为了避免格式错误，应充分使用制表位、\b边距、对齐方式 等 Word 格式设置代替原文档中的大量空格。 \b类的使用方法所有类\b一览下面是\b模块中的所有类： IDocField 接口：表示\b文档中的字段。 DocElementField 类：\b单子段。 DocTableField 类：\b\b表格。 DocFieldType 枚举：表示文档字段的类型。 DocTableFieldHeader 类：表示\b表头。 DocTableFieldCell 类：表示表单元格。 DocGenerator 类：\b文档渲染器。 类的详细信息可参考 JavaDoc。 \b\b基本使用\b创建 DocGenerator 对象，\b\b设置其\b以下属性： docPath：\b源文档路径。 docSavePath：生成文档的保存路径。 fieldMap：字段映射，为键值对形式。键即为文档模板键，值为 IDocField 对象。 然后调用 loadDocument() 方法加载文档，使用 replaceInDoc() \b方法生成文档。 \b\b完成示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.zkty.hbh;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.poi.xwpf.usermodel.UnderlinePatterns;public class App &#123; public static void main( String[] args ) &#123; DocGenerator generator = new DocGenerator(); generator.docPath = \"/formCaseSource.docx\"; generator.docSavePath = \"/formCaseSource-output.docx\"; generator.fieldMap.put(\"$&#123;EL_reportYear&#125;\", new DocElementField(\"2017\")); generator.fieldMap.put(\"$&#123;EL_reportMonth&#125;\", new DocElementField(\"3\")); generator.fieldMap.put(\"$&#123;EL_reportDay&#125;\", new DocElementField(\"19\")); generator.fieldMap.put(\"$&#123;EL_reportHour&#125;\", new DocElementField(\"19\")); // 创建表格参数 List&lt;DocTableFieldHeader&gt; headerMap = new ArrayList&lt;DocTableFieldHeader&gt;(); headerMap.add(new DocTableFieldHeader(\"test1\", \"测试1\")); headerMap.add(new DocTableFieldHeader(\"test2\", \"测试2\")); headerMap.add(new DocTableFieldHeader(\"test3\", \"测试3\")); DocTableFieldHeader header4 = new DocTableFieldHeader(\"test4\", \"测试4\"); header4.width = 2000; headerMap.add(header4); headerMap.add(new DocTableFieldHeader(\"test5\", \"测试5\")); List&lt;Map&lt;String, DocTableFieldCell&gt;&gt; contentMap = new ArrayList&lt;Map&lt;String, DocTableFieldCell&gt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; Map&lt;String, DocTableFieldCell&gt; content = new HashMap&lt;String, DocTableFieldCell&gt;(); for (int j = 0; j &lt; 5; j++) &#123; content.put(\"test\" + (j + 1), new DocTableFieldCell((\"测试内容\" + (i + 1)) + (j + 1))); &#125; contentMap.add(content); &#125; generator.fieldMap.put(\"$&#123;TB_demo&#125;\", new DocTableField(headerMap, contentMap)); try &#123; generator.loadDocument(); generator.showDocument(); generator.replaceInDoc(); generator.showDocument(); generator.saveDocument(); &#125; catch (IOException e) &#123; System.out.println(\"Open document filed!\"); e.printStackTrace(); &#125; &#125;&#125; 其他使用方法如果当前定义的\b两个字段类渲染出的样式无法满足需求，\b可以从其派生， \b派生后添加自己的\b\b属性，\b然后重载 setStyle() 函数，自定义样式。 生成效果图示","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[{"name":"Apache POI","slug":"Apache-POI","permalink":"http://hpdell.github.io/tags/Apache-POI/"}]},{"title":"VS 下 GeoDa 开发环境配置","slug":"geoda-setup","date":"2018-03-09T18:58:45.000Z","updated":"2019-01-22T14:33:19.086Z","comments":true,"path":"编程/geoda-setup/","link":"","permalink":"http://hpdell.github.io/编程/geoda-setup/","excerpt":"最近帮师兄配置 GeoDa 的环境，顺便记录下。","text":"最近帮师兄配置 GeoDa 的环境，顺便记录下。 目录： 依赖库下载与安装 下载依赖库 安装依赖库 GDAL 编译安装 wxWidgets 编译 Eigen Boost 编译 BLAS 和 CLAPACK 库编译 SQLite 编译、cURL 编译、 json_spirit 编译 GeoDa 的编译 主要会用到一些工具： Visual Studio 的命令提示符，主要用到 nmake 命令。 Visual Studio，我使用的是 Visual Studio 2017。 Internet Download Manager(IDM)，用于下载依赖库。 CMake，用于编译一些库。 MinGW，用于编译 Fortan 源码和一些库。 下面分别说明编译过程 依赖库下载与安装下载依赖库 GeoDa 要下载依赖库，吧？要的吧？官网没说啊。但是感觉肯定要吧。都没说哪些怎么下载啊！！！ 具体这个工程用到什么依赖库，可以在项目设置的“附加依赖项”中进行查看。 根据官网给出的 README 文件，需要运行一个 Build.bat 的批处理文件。 但是运行这个文件后，会开始下载一些依赖库。 由于依赖库放在亚马逊云上，国内往往是访问不到的。 因此需要提取出 Build.bat 中的下载链接，手动下载这些包。 还有一种方法，就是把这些第三方库分别从其官网下载对应的版本。 如果一个一个找下载链接，那就太慢了。这时可以使用 IDM 提取剪贴板内下载链接的功能，批量下载。 具体过程就不详述了。需要注意的是，MySQL 按照文件中给出的地址是无法下载的，需要自己下载。 安装依赖库这里就要大量使用到 VS 的命令提示符了，大量使用 nmake 以命令行的方式安装。 GDAL 编译安装 致谢：在土哥大神的指导下，我完成了 GDAL 的编译和安装。编译详细信息可参见 nmake.opt 文件。 编译 GDAL 之前要编译 GEOS 、 proj4 两个库。编译方法见后面。 在 GDAL 的安装目录（下文使用 %GDAL_HOME% 以模拟环境变量的方式表示）下，运行以下命令 1nmake -f makefile.vc MSVC_VER=1910 DEBUG=1 需要注意的是，MSVC_VER 变量代表了编译器的版本。 使用对应的版本号替换即可。另外， DEBUG 参数为 1 表示以 DEBUG 方式编译，为 0 表示以 RELEASE 方式编译。 编译完成后，需要安装 GDAL，才能把库文件放置在硬盘上。在 nmake.opt 文件中，找到下面行并修改： 12- GDAL_HOME = \"C:\\warmerda\\bld\"+ GDAL_HOME = \"D:\\lib\\gdal\" 然后运行命令 12nmake -f makefile.vc MSVC_VER=1910 DEBUG=1 DEVINSTALL # DEBUG 环境下nmake -f makefile.vc MSVC_VER=1910 DEBUG=1 INSTALL # RELEASE 环境下 就可以把库文件放置在 GDAL_HOME 设定的目录中。 编译完成后，将 %GDAL_HOME%\\include 路径添加到 GeoDa 工程的包含目录中； 将 %GDAL_HOME%\\lib 路径添加到 GeoDa 工程的库目录中。 MSVC_VER 值 版本号 1910 15.0(2017) 1900 14.0(2015) 1800 12.0(2013) 1700 11.0(2012) 1600 10.0(2010) 1500 9.0 (2008) 1400 8.0 (2005) - specific compilation flags, different from older VC++ 1310 7.1 (2003) # is it still supported ? 1300 7.0 (2002) # is it still supported ? wxWidgets 编译wxWidgets 是开源跨平台的 GUI 库，GeoDa 的界面基于 wxWidgets。 但是为了多语言，wxWidgets 使用 Unicode 编译，因此 GeoDa 也要用 Unicode 编译。在咨询了开发人员之后 （Issus #1598: Why use a wxWidgets built in unicode?）， 他们告诉了我正确的编译方式。 设 wxWidgets 的源文件目录为 %WX_HOME%， 则它的 makefile.vc 文件位于 %WX_HOME%\\build\\msw，其编译指令如下： 1nmake -f makefile.vc UNICODE=1 SHARED=1 RUNTIME_LIBS=dynamic MONOLITHIC=1 USE_OPENGL=1 USE_POSTSCRIPT=1 TARGET_CPU=AMD64 这里的参数： BUILD=debug 表示 DEBUG 方式编译。如果要 RELEASE 方式编译，使用 BUILD=release。 MONOLIHIC=1 表示将所有的库打包到一个文件中，参见 WxWidgets Build Configurations 这种方式编译时，必须编译动态库。 SHARED=1 表示编译 DLL 动态链接库。 RUNTIME_LIBS=dynamic 表示编译动态运行时库。 编译完成后，将 %WX_HOME%\\include、%WX_HOME%\\include\\msvc 路径添加到 GeoDa 工程的包含目录中； GeoDa 需要 %WX_HOME%\\lib\\vc_lib\\mswud\\msvc\\setup.h 头文件，请确保其存在 EigenEigen 是矩阵运算的库，无需编译。设 Eigen 的源文件目录为 %EIGEN_HOME%， 则将 %EIGEN_HOME% 路径添加到 GeoDa 工程的包含目录中即可。 SQLite 相同。 Boost 编译 参考 [boost 1.56.0 编译及使用][boost-build-blog]，版本不同但方法相同。 下载 Boost 库后，设目录为 %BOOST_SRC_HOME%，使用 VS 命令提示符运行 %BOOST_SRC_HOME%\\bootstrap.bat批处理文件。 可以得到 b2.exe 和 bjam.exe，两个文件作用相同。 我用的编译命令是： 1b2 install --toolset=msvc-9.0 --without-python --prefix=\"E:\\SDK\\boost\\bin\\vc9\" link=static runtime-link=shared runtime-link=static threading=multi debug release 参数含义是： 参数 含义 stage/install stage表示只生成库（dll和lib），install还会生成包含头文件的include目录。 toolset 指定编译器，可选的如borland、gcc、msvc（VC6）、msvc-9.0（VS2008）等。 without/with 选择不编译/编译哪些库。 stagedir/prefix stage时使用stagedir，install时使用prefix，表示编译生成文件的路径。推荐给不同的IDE指定不同的目录。 build-dir 编译生成的中间文件的路径。这里记为 %BOOST_HOME%。 link 生成动态链接库/静态链接库。生成动态链接库需使用shared方式，生成静态链接库需使用static方式。 runtime-link 动态/静态链接C/C++运行时库。同样有shared和static两种方式，这样runtime-link和link一共可以产生4种组合方式，各人可以根据自己的需要选择编译。 threading 单/多线程编译。 debug/release 编译debug/release版本。 link 和 runtime-link 的缺省配置是 link=static、runtime-link=shared。 编译完成后，将 %BOOST_HOME%\\include 路径添加到 GeoDa 工程的包含目录中； 将 %BOOST_HOME%\\lib 路径添加到 GeoDa 工程的库目录中， 在“附加依赖项”中修改引用的 Boost 库 lib 的版本。 由于 GeoDa 只引用了 thread 这一个模块，因此可以只编译这一个模块，减少编译时间。 BLAS 和 CLAPACK 库编译BALS 和 CLAPACK 都是 GeoDa 的依赖库，但是 BALS 已经包括在 CLAPACK 中。只需要编译 CLAPACK 即可。 下载 CLAPACK 的 VS 解决方案，完成后打开解决方案文件，运行 VS 编译即可。 官网给出的是使用 CMake 编译的方法，但是我在用 CMake 的时候总是报错，所以直接找了解决方案。 SQLite 编译、cURL 编译、 json_spirit 编译有人在 GitHub 上开源了 SQLite3 的 CMakeLists 文件，可以直接拿来编译。 克隆其 GitHub 仓库： 1git clone https://github.com/snikulov/sqlite.cmake.build.git 使用 CMake 创建 VS 工程。 打开工程后，直接编译即可。 其他两个库的方法相同。 GeoDa 的编译把上面这些依赖库编译好了之后，打开 GeoDa 的 VS 工程，要进行如下修改： 将项目设置为使用 Unicode 编译。 包含目录和库目录加入之前编译的依赖库。 附加依赖项中， Boost 依赖项改为编译出来的依赖项； 所有 wx 开头的依赖项，结尾如果是 d 不是 ud 的，改为 ud； 其他依赖项如果名称有误，改为编译出来的名称。 然后可以执行编译。 GeoDa 编译的工作实在是太繁重了，因此本文未完，将来会更新编译的最新进展。","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[]},{"title":"Vue 与 jQuery Mobile 混用","slug":"vue-jqm-note","date":"2018-01-25T11:23:06.000Z","updated":"2019-01-22T14:33:19.158Z","comments":true,"path":"编程/vue-jqm-note/","link":"","permalink":"http://hpdell.github.io/编程/vue-jqm-note/","excerpt":"由于项目需要，在手机端定下的框架是 jQuery Mobile。但由于应用比较大，没有 MVVM 支持会越来越困难。 正好想尝试 Vue ，于是就直接开始 Vue 和 jQuery Mobile 混用的挖坑之路。","text":"由于项目需要，在手机端定下的框架是 jQuery Mobile。但由于应用比较大，没有 MVVM 支持会越来越困难。 正好想尝试 Vue ，于是就直接开始 Vue 和 jQuery Mobile 混用的挖坑之路。 经验Detail 视图、表单自动生成大纲-细节 (Master-Detail) 视图是经常用到的。每个对象的信息都不一样，而且往往会很多。我们这个项目中，起码有 20+ 的对象需要展示和填写。如果每个细节视图都像下面这样做，那工程量会非常大。 HTML 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;ul id=\"content\" data-role=\"listview\" data-inset=\"false\"&gt; &lt;li&gt; &lt;b&gt;联系人员&lt;/b&gt; &lt;span class=\"listview-aside\"&gt;&#123;&#123; item.call_person &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;b&gt;联系电话&lt;/b&gt; &lt;span class=\"listview-aside\"&gt;&#123;&#123; item.call_num &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;b&gt;签发日期&lt;/b&gt; &lt;span class=\"listview-aside\"&gt;&#123;&#123; item.call_date &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt;``` &gt; 这样结合了 Vue，利用 Visual Studio Code 多点编辑的功能虽然也不慢，但是可以使用 Vue 寻求更简单的生成方式。我们可以对这个页面所表示的对象建立一个类，比如就叫 `Call`，为这个类编写一个公有 `Array` 属性 `domMap`，表示将这个类映射到 DOM 元素上：`JavaScript```` JavaScriptCall.prototype.domMap = [ &#123; key: \"call_person\", name: \"联系人员\", type: \"text\", hidden: false &#125;,&#123; key: \"call_num\", name: \"联系电话\", type: \"tel\", hidden: false &#125;,&#123; key: \"call_date\", name: \"签发日期\", type: \"date\", hidden: &#123; listview: false, form: true &#125; &#125;] 前端根据这个 domMap 自动生成 DOM 元素。 HTML 1234567&lt;ul data-role=\"listview\" data-inset=\"true\"&gt; &lt;li v-for=\"(dommap, index) in detail.domMap\" v-if=\"!dommap.hidden &amp;&amp; !dommap.hidden.listview\"&gt; &lt;b&gt;&#123;&#123; dommap.name &#125;&#125;&lt;/b&gt; &lt;p v-if=\"dommap.type === 'textarea'\" class=\"listview-aside\"&gt;&#123;&#123; detail[dommap.key] &#125;&#125;&lt;/p&gt; &lt;span v-else class=\"listview-aside\"&gt;&#123;&#123; detail[dommap.key] &#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; detail 是 Vue 对象中的一个属性，即当前详情列表所表示的对象。 同理 form 也可以自动生成。碰到 type 是 textarea 的时候，生成一个 &lt;textarea&gt; 元素；其他情况下生成 &lt;input&gt; 元素，其 type 属性根据 domMap 中的 type 属性确定即可。 表单元素动态添加甲方提出了在一个页面行动态添加行进行填写的要求，最后还要 Ajax 提交。 如果用 jQuery 的话，需要在 HTML 元素中 Append 一段 HTML 代码， 提交时循环查找所有行，然后组合成表单，最后提交。 但是用 Vue 的话，只需要在 HTML 上做好绑定，然后给被绑定的数组对象添加元素即可。 方便了很多。我们网页端是用纯 jQuery 编写的，移动端我用的 Vue。 HTML 1234567891011121314151617181920212223242526272829303132333435&lt;form id=\"index-form\"&gt; &lt;div v-for=\"(ind, index) in form.wInsRecordZs\" class=\"nd2-card\"&gt; &lt;div class=\"card-title\"&gt; &lt;h3 class=\"card-primary-title\"&gt; 相关检测指数&#123;&#123; index + 1 &#125;&#125; &lt;/h3&gt; &lt;/div&gt; &lt;div class=\"card-supporting-text has-action has-title\"&gt; &lt;div class=\"ui-field-contain\"&gt; &lt;label v-bind:for=\"'zs_' + index\"&gt;指数（单位）&lt;/label&gt; &lt;input type=\"text\" name=\"zs\" v-bind:id=\"'zs_' + index\" value=\"\" v-model=\"form.wInsRecordZs[index].zs\"/&gt; &lt;/div&gt; &lt;div class=\"ui-field-contain\"&gt; &lt;label v-bind:for=\"'value_' + index\"&gt;值&lt;/label&gt; &lt;input type=\"text\" name=\"value\" v-bind:id=\"'value_' + index\" value=\"\" v-model=\"form.wInsRecordZs[index].value\"/&gt; &lt;/div&gt; &lt;div class=\"ui-field-contain\"&gt; &lt;label v-bind:for=\"'stand_' + index\"&gt;标准&lt;/label&gt; &lt;input type=\"text\" name=\"stand\" v-bind:id=\"'stand_' + index\" value=\"\" v-model=\"form.wInsRecordZs[index].stand\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"card-action\"&gt; &lt;div class=\"row between-xs\"&gt; &lt;div class=\"col-xs-12 align-right\"&gt; &lt;a href=\"#\" class=\"ui-btn clr-primary ui-btn-inline\" v-on:click=\"minusInticator(index)\"&gt;删除 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;div class=\"row between-xs\"&gt; &lt;div class=\"col-xs-12 align-center\"&gt; &lt;button href=\"#\" class=\"ui-btn ui-btn-icon-left ui-btn-inline clr-primary\" v-on:click=\"addIndicator()\"&gt;添加检测指数 &lt;/button&gt; &lt;button href=\"#\" class=\"ui-btn ui-btn-icon-left ui-btn-inline\" v-on:click=\"clean()\"&gt;清空 &lt;/button&gt; &lt;button class=\"ui-btn ui-btn-icon-left ui-btn-inline ui-btn-raised clr-primary\" v-on:click=\"submit()\"&gt; 提交 &lt;/button&gt; &lt;/div&gt;&lt;/div&gt; JavaScript 123456789101112131415161718192021222324252627282930313233343536373839var vm = new Vue(&#123; el: \"#index-form\", data: &#123; form: &#123; wInsRecordZs: [] &#125; &#125;, methods: &#123; addIndicator: function () &#123; this.form.wInsRecordZs.push(new Indicator()); setTimeout(function () &#123; $(\"form\").trigger(\"create\") &#125;, 10) &#125;, submit: function () &#123; $.ajax(&#123; type: \"POST\", url: \"http://127.0.0.1:3000/WInsR/save\", data: mainpageVM.form.toForm().substr(1), success: function () &#123; new $.nd2Toast(&#123; message : \"提交成功\", // Required &#125;); &#125;, error: function() &#123; new $.nd2Toast(&#123; message : \"提交失败\", // Required &#125;); &#125; &#125;); &#125;, clean: function () &#123; mainpageVM.form.clean(); &#125;, minusInticator: function (index) &#123; mainpageVM.form.wInsRecordZs.splice(index, 1); &#125; &#125;&#125;) 开发网页端的那个哥们表示：他跟不上我的进度了。 踩坑表单元素对于input类型是text tel number这些需要输入的表单元素，没有什么问题。 使用第三方插件提供支持的date time datetime类型元素，也没有问题。 但是对于radio checkbox这两个元素，实测 jQuery Mobile 和 Vue 无法自动结合。 例如 HTML 1234567&lt;fieldset id=\"fieldset\" data-role=\"controlgroup\"&gt; &lt;legend&gt;项目状态&lt;/legend&gt; &lt;label&gt;&lt;input v-model=\"form.project_state\" type=\"radio\" name=\"project_state\" value=\"在建\"/&gt;在建&lt;/label&gt; &lt;label&gt;&lt;input v-model=\"form.project_state\" type=\"radio\" name=\"project_state\" value=\"改扩建\"/&gt;改扩建&lt;/label&gt; &lt;label&gt;&lt;input v-model=\"form.project_state\" type=\"radio\" name=\"project_state\" value=\"生产\"/&gt;生产&lt;/label&gt; &lt;label&gt;&lt;input v-model=\"form.project_state\" type=\"radio\" name=\"project_state\" value=\"停产\"/&gt;停产&lt;/label&gt;&lt;/fieldset&gt; JavaScript 12345678var content = new Vue(&#123; el: \"fieldset\", data: &#123; form: &#123; project_state: \"\" &#125; &#125;&#125;) 这种情况下，进行单选操作，content.form.project_state的值是不更改的， 有可能是 jQuery Mobile 在实现的时候，阻断了事件的传播，Vue 无法获取到真正的值。 如果希望更改 Vue 对象中的值，那么需要给每个按钮元素加上onclick事件响应函数，替换v-model绑定。 HTML 1234567&lt;fieldset id=\"fieldset\" data-role=\"controlgroup\"&gt; &lt;legend&gt;项目状态&lt;/legend&gt; &lt;label&gt;&lt;input v-model=\"form.project_state\" type=\"radio\" name=\"project_state\" onclick=\"content.form.project_state= '在建'\" value=\"在建\"/&gt;在建&lt;/label&gt; &lt;label&gt;&lt;input v-model=\"form.project_state\" type=\"radio\" name=\"project_state\" onclick=\"content.form.project_state= '改扩建'\" value=\"改扩建\"/&gt;改扩建&lt;/label&gt; &lt;label&gt;&lt;input v-model=\"form.project_state\" type=\"radio\" name=\"project_state\" onclick=\"content.form.project_state= '生产'\" value=\"生产\"/&gt;生产&lt;/label&gt; &lt;label&gt;&lt;input v-model=\"form.project_state\" type=\"radio\" name=\"project_state\" onclick=\"content.form.project_state= '停产'\" value=\"停产\"/&gt;停产&lt;/label&gt;&lt;/fieldset&gt; 现在这样就可以更改content中的值了。 但是有趣的是，如果你使用了v-model绑定元素到某个对象（例如这里的project_state）， 那么当你在初始化 Vue 对象的时候，对该对象（project_state）赋值， 绑定到它的单选按钮组会自动根据该对象的值进行初始化。 比如你设置了project_state的初始值为“生产”， 那么“生产”对应的第三个单选按钮会在文档初始化的过程中被选中。 动态加载 DOM 元素按照 jQuery Mobile 官网上的示例，所有标签的样式在编写 HTML 文档的时候， 都使用 data- 属性确定，文档加载完毕后会自动初始化并加载样式。 当在文档中使用 Vue 动态添加元素的时候，就会出现没有样式的情况。 解决这个问题的办法有两个。 如果元素只需要使用 jQuery Mobile 的样式，在使用 v-for 的时候，直接指定元素的 class 属性，同时也加上 data- 属性。 如果元素需要 jQuery Mobile 自带的一些事件响应（比如 collapsible 元素，点击标头需要可以展开或折叠其内容。这时，在添加元素事件发生后，在其父元素上触发create事件。例如：我在表单中根据 Vue 绑定值 form.wInsRecordZs[] 动态添加一个 collapsible，就可以这样做 1234this.form.wInsRecordZs.push(new Indicator());setTimeout(function() &#123; $(\"form\").trigger(\"create\")&#125;, 10) 其中 trigger(&quot;create&quot;) 方法可以让 jQuery Mobile 对添加的元素自动初始化。设置一段时间后再触发是实践的结果，绑定的数组添加后，DOM 元素不一定立刻添加了，需要等一小段时间才能添加。我们设置一段延迟，保证在 DOM 元素已经添加之后，再触发 create 事件。","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://hpdell.github.io/tags/Vue/"},{"name":"jQuery Mobile","slug":"jQuery-Mobile","permalink":"http://hpdell.github.io/tags/jQuery-Mobile/"},{"name":"网页开发","slug":"网页开发","permalink":"http://hpdell.github.io/tags/网页开发/"}]},{"title":"Path-Inference-Filter(PIF) 算法调用的实现","slug":"implementation-pif","date":"2018-01-04T17:29:57.000Z","updated":"2019-01-22T14:33:19.086Z","comments":true,"path":"编程/implementation-pif/","link":"","permalink":"http://hpdell.github.io/编程/implementation-pif/","excerpt":"Path Inference Filter(PIF, 道路推断滤波)算法是一种基于概率的路网匹配算法。其核心代码已经开源在 GitHub 上，作者也提供了一个example.py文件，来介绍如何使用。我由于需要将此算法真实用于路网匹配中，因此需要根据实际路网对此算法进行调用。之前使用 ArcPy 写了一个，但是运行速度非常慢，而且跑着跑着电脑就自动关机了。所以现在就用 PostGIS 和 pgRouting 重新实现一个版本。","text":"Path Inference Filter(PIF, 道路推断滤波)算法是一种基于概率的路网匹配算法。其核心代码已经开源在 GitHub 上，作者也提供了一个example.py文件，来介绍如何使用。我由于需要将此算法真实用于路网匹配中，因此需要根据实际路网对此算法进行调用。之前使用 ArcPy 写了一个，但是运行速度非常慢，而且跑着跑着电脑就自动关机了。所以现在就用 PostGIS 和 pgRouting 重新实现一个版本。 PIF 的数学原理此处详细情况请参考论文 The Path Inference Filter: Model-Based Low-Latency Map Matching of Probe Vehicle Data 。后面我会补充一个自己整理的简略版原理。 PIF 的接口调用PIF 核心库提供了一些类供我们使用。比如： State和StateCollection：描述状态值的类及状态值的集合。 LatLng：表示经纬度的对象。 PathBuilder：路径建立类。用于生成状态值之间的可达路径。 LearningTrajectory：用于获取轨迹的描述。 TrajectoryViterbi1：用于计算概率最大的轨迹。 TrajectorySmoother1：用于滤波。 State、StateCollection、LatLng三个类可以直接使用。对于我们拿到的 GPS 数据来说，一般都会有一些附加的属性值，例如速度、方向、车辆状态等。可以创建自己的继承自LatLng和State的子类，添加这些属性。 我们可以将一些常用的函数，封装到类WuhanRoadFilter中，例如：计算距离的函数distance、计算状态值特征向量和路径特征向量的函数等。该类的形式如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class WuhanRoadFilter: ''' 路径滤波类 对武汉市道路网络数据和Path-Inference-Path的封装。 属性： - `network`: 网络数据集 - `line_features`: 要素数据集 ''' def __init__(self, conn): ''' 构造函数 ''' self.conn = conn # type: psycopg2.exetensions.connection def distance(self, coord1: LatLng, coord2: LatLng) -&gt; float: ''' 求两地理坐标之间的距离 - `coord1`: 经纬度坐标值 - `coord2`: 经纬度坐标值 - `spatial_ref`: 空间参考。默认为GCS_WGS_1984 ''' pass def point_feature_vector(self, state_collection: StateCollection): \"\"\" 点的特征向量 \"\"\" pass def path_feature_vector(self, select_path: Tuple[State, List, State, float]): \"\"\" 路径的特征向量 \"\"\" pass def get_posibility_states(self, point: TaxiPoint, distance: float): ''' 获取最可能的状态 参数： - `link_id`: 路段ID - `point`: 要寻找的点。格式为(lon, lat)的二元组 返回值: StateCollection ''' pass def create_observations(self, file_path: str, filting=0) -&gt; List[List[StateCollection]]: ''' 创建观测值 参数： - `file_path`: 观测值XML文件路径 - `filting`: 观测值序列最少的点数 ''' pass 在调用过程中，可以创建PathBuilder的子类，来实现自己的路径搜索。子类中只需要实现方法getPaths()。此方法用于在方法getPathsBetweenCollections()中调用以获取路径。必须实现，否则会抛出NotImplementedError的错误。我们创建类WuhanRoadBuilder，在该类中实现getPaths()方法。该类的形式如下： 12345678910111213141516class WuhanRoadBuilder(PathBuilder): ''' 武汉市路网的路径工厂 路径工厂会生成两个状态集合之间的所有路径 ''' def __init__(self, conn): # PathBuilder.__init__() self.conn = conn # type: psycopg2.extensions.connection def getPaths(self, s1: State, s2: State): ''' 获取两个状态之间的路径 利用ArcPy获取路网上两点之间的最短路径 ''' pass 这些函数和 PIF 框架的调用过程可参考 PIF 库中的example.py文件。 利用 pgRouting 实现调用 PIF 算法借助 PostGIS 和 pgRouting 可以实现路径搜索功能，而使用 PostGIS 提供的大量的关于几何和地理数据的函数，可以方便实现对 PIF 算法的调用。但是这里需要编写的数据库函数，需要一定的数据库编程的能力。为了能够和 Python 编写的 PIF 核心代码结合起来，需要使用 Python 调用 PostgreSQL 函数，并将结果转化为 Geometry 及其子类型的对象。 使用到的 Python 包使用下面两个包即可： psycopg2：封装了对 PostgreSQL 数据库的操作。 postgis：封装了 PostGIS 空间类型。 准备路网数据假设我们要导入的路网数据名字叫road。一般情况下，我们拿到的数据，坐标系为 WGS84 或常用的投影坐标系（如CGCS2000）。在 WGS84 坐标系下的数据，以Geography类型存储在数据库中，在投影坐标系下的数据，以Geometry类型存储在数据库中。在 PostGIS 的文档中，建议使用Geometry类型存储数据，以减小计算量。 The geography type allows you to store data in longitude/latitude coordinates, but at a cost: there are fewer functions defined on GEOGRAPHY than there are on GEOMETRY; those functions that are defined take more CPU time to execute. Geography 类型允许你以经纬度坐标的方式存储数据，但是代价是：Geography 类型比 Geometry 类型的函数少；Geography 类型的函数执行起来消耗更多的 CPU 时间。 The type you choose should be conditioned on the expected working area of the application you are building. Will your data span the globe or a large continental area, or is it local to a state, county or municipality? If your data is contained in a small area, you might find that choosing an appropriate projection and using GEOMETRY is the best solution, in terms of performance and functionality available. If your data is global or covers a continental region, you may find that GEOGRAPHY allows you to build a system without having to worry about projection details. You store your data in longitude/latitude, and use the functions that have been defined on GEOGRAPHY. If you don’t understand projections, and you don’t want to learn about them, and you’re prepared to accept the limitations in functionality available in GEOGRAPHY, then it might be easier for you to use GEOGRAPHY than GEOMETRY. Simply load your data up as longitude/latitude and go from there. 因此，我们采用投影坐标系的路网数据。 数据导入导入时数据的方法非常简单，使用 PostGIS Shapefiel Import/Export Manager(PostGIS 2.0 Shapefile and DBF Loader Exporter) 工具导入即可。 在这个工具上设置数据库的连接，选择要导入的 shp 文件。选定 shp 文件后，最好点击 Options 按钮打开选项，选中最后一个复选框。 确定后，点击 Improt 按钮开始导入。等待其完成即可。 需要注意的是，shp 文件的名字，会作为最终导入到数据库中表的名字。 拓扑关系建立我们导入的数据集，在网络结构中数据“边”类型，pgRouting 称之为 edge。pgRouting 需要知道每个 edge 的起点和终点的序号是什么，需要知道路径的长度是多少。需要给road数据集添加三个字段：source、target和length： 1234ALTER TABLE road ADD COLUMN source integer;ALTER TABLE road ADD COLUMN target integer;ALTER TABLE road ADD COLUMN length double precision;UPDATE road set length = ST_Length(geom); -- 为路段长度赋值 当然这两个字段的名字可以自己取。路径长度字段如果已经有了，也可以不用重新建立。 然后是拓扑关系的建立。使用 pgRouting 提供的函数 pgr_createTopology() 来创建拓扑，该函数有以下参数： 参数名 说明 edge_table 路网表名（也可以包含数据库名）。文本类型。 tolerance 路段不连续误差。8字节浮点数类型。 the_geom 路网表中 Geometry 列的名称（默认是”the_geom”）。文本类型。 id 路网表中主键列的名称（默认是”id”）。文本类型。 source 路网表中 source 列的名称（默认是”source”）。文本类型。 target 路网表中 target 列的名称（默认是”target”）。文本类型。 rows_where 用于选择一个子集或多行的 SELECT 条件。默认值是选择所有 source 和 target 为空的行。文本类型。 clean 是否清除之前的拓扑关系（默认是 false ）。布尔型。 具体调用实例为： 1SELECT pgr_createTopology('public.road', 0.001, 'geom', 'gid'); 路网数据准备完成。 计算两点间距离这里只需要使用到 PostGIS 提供的函数ST_Distance()，函数的用法非常简单，可参考官网文档。为了方便调用，我们设计一个数据库函数PIF_GetDistance()，使其可以直接输入两个坐标值，进行距离计算。 1234567891011121314CREATE OR REPLACE FUNCTION \"public\".\"PIF_GetDistance\"(\"x1\" float8, \"y1\" float8, \"x2\" float8, \"y2\" float8) RETURNS \"pg_catalog\".\"float8\" AS $BODY$DECLARE point1 Geometry := ST_Transform(ST_SetSrid(ST_Point(x1, y1), 4326), 3857); point2 Geometry := ST_Transform(ST_SetSrid(ST_Point(x2, y2), 4326), 3857);BEGIN -- Routine body goes here... RETURN ST_Distance(point1, point2);END$BODY$ LANGUAGE plpgsql VOLATILE COST 100 Python 中调用此函数： 12345678910def distance(self, coord1: LatLng, coord2: LatLng) -&gt; float: ''' 求两地理坐标之间的距离 - `coord1`: 经纬度坐标值 - `coord2`: 经纬度坐标值 - `spatial_ref`: 空间参考。默认为GCS_WGS_1984 ''' cur = self.conn.cursor() cur.execute('SELECT \"PIF_GetDistance\"(%s, %s, %s, %s)', (coord1.lng, coord1.lat, coord2.lng, coord2.lat)) return cur.fetchone()[0] 获取每个 GPS 点对应的状态值状态值的获取是在一个路段上计算一个联合分布 $$ π(x|g) = ω(g|x)Ω(x) $$ 其中 $ x $ 是状态值，$ g $ 是 GPS 观测值。但是由于分布 $ ω(g|x) $ 服从正态分布，$ Ω(x) $ 在没有先验知识的情况下，服从均匀分布，因此直接取路段上距离 GPS 观测值最近的点即可。 需要使用到的 PostGIS 函数编写这个数据库函数，需要用到 PostGIS 提供的一些函数，如下（参考 PostGIS 文档）： 函数 用途 ST_Point(float, float) 构造 Point 对象的函数。 ST_SetSRID(geometry, integer) 设置对象的 SRID（即空间参考）。 ST_Transform(geometry, integer) 将 Geometry 对象进行投影转换。 ST_StartPoint(geometry) LineString Geometry 对象的第一个点。 ST_EndPoint(geometry) LineString Geometry 对象的最后一个点。 ST_ClosestPoint(geometry, geometry) 返回第一个 Geometry 对象上距离第二个 Geometry 对象最近的点。 ST_LineLocatePoint(geometry a_linestring, geometry a_point) 返回a_line上距离a_point最近的点在a_line上的百分比。 编写 PostgreSQL 函数函数实现的思路是：首先按照范围筛选处距离指定 GPS 观测值一定距离（例如 100 m）内的路段，然后在这些路段上计算每个最近点。 数据库函数PIF_GetStatesAtPosition()的定义如下： 1234567891011121314151617181920212223242526CREATE OR REPLACE FUNCTION public.pif_GetStatesAtPosition( lon float, lat float, distance float)RETURNS TABLE(StartPoint geometry, EndPoint geometry, States geometry, Locate float8, shape_leng numeric) AS $$declare point_g geometry := ST_Transform(ST_SetSRID(ST_Point(lon, lat), 4326), 3857);begin RETURN QUERY SELECT ST_Transform(ST_SetSrid(ST_StartPoint(near_lines.geom), 3857), 4326) AS StartPoint, ST_Transform(ST_SetSrid(ST_EndPoint(near_lines.geom), 3857), 4326) AS EndPoint, ST_Transform(ST_ClosestPoint(ST_SetSRID(near_lines.geom, 3857), point_g), 4326) AS States, ST_LineLocatePoint(ST_SetSRID(near_lines.geom, 3857), point_g) AS Locate, near_lines.shape_leng FROM ( SELECT road.geom, road.shape_leng FROM public.road WHERE geom &lt;-&gt; point_g &lt; distance ) AS near_lines;end;$$ LANGUAGE 'plpgsql';ALTER FUNCTION public.pif_GetStatesAtPosition(float, float, float) OWNER TO postgres; 为了避免投影误差，可以将所有结果中的坐标直接以 EPSJ:3857 坐标返回，下次调用时直接用这个坐标系的坐标。这样做同时也可以减少计算量。 Python 函数的编写使用 Python 调用这个函数时，直接使用 psycopg2 包查询该函数即可。对于返回结果进行处理，分别创建State对象，最后添加到StateCollection对象中，并返回。 1234567891011121314151617181920212223def get_posibility_states(self, point: TaxiPoint, distance: float): ''' 获取最可能的状态 参数： - `link_id`: 路段ID - `point`: 要寻找的点。格式为(lon, lat)的二元组 返回值: StateCollection ''' self.cur.execute(\"SELECT startpoint, endpoint, states, locate, shape_leng \" + \"FROM public.pif_getstatesatposition(%s, %s, %s)\", (point.lng, point.lat, distance)) states = [] # type: List[State] for row in self.cur: start_point = row[0] # type: postgis.Point end_point = row[1] # type: postgis.Point closest_point = row[2] # type: postgis.Point locate = row[3] # type: float shape_leng = row[4] # type: float link_id = ((start_point.x, start_point.y), (end_point.x, end_point.y)) cur_state = State(link_id, locate * float(shape_leng), point) states.append(cur_state) return StateCollection(None, states, LatLng(closest_point.y, closest_point.x), None) 这种查询的方法同样适合于其他支持空间数据的数据库，以及其他类型的语言，例如 C# 和 Java 语言，数据库也可以换成 SQL Server 等其他数据库。问题在于，几乎运行前期绝大部分计算任务都在数据库中完成，数据库计算的压力会比较大，选择一个合适的数据库非常重要。 获取状态值间的最短路径根据 PIF 算法的原理，将 GPS 点映射至 $ I^t $ 个元素的候选状态集合 $ \\mathbf{x}^t = {x_1^t, x_2^t, ⋯, x_{I^t}^t} $ ，再映射至 $ J^t $ 个元素的路经集合。即对于 $ ∀x_i^t ∈ x^t, \\mathbf{x}_i^{t+1} \\in \\mathbf{x}^{t+1} $，都构造一条路径。路径集记为 $ \\mathbf{p}^t $，轨迹为：$$ τ = x_1p_1x_2⋯p_{t-1}x_t $$ PIF 会根据车辆轨迹计算概率，最终取概率最高的一条轨迹作为出租车 GPS 序列再地图上匹配得到的轨迹。 数据库函数的编写PostgreSQL 数据库的插件 pgRouting 提供了路径规划的能力。在建立拓扑关系后，可以使用路径规划系列函数求解最短路径。 pgr_dijkstra()：使用 Dijkstra 算法求解的最短路径。除此之外，还有求解代价的 Dijkstra 函数。 pgr_aStar()：使用 A* 算法求解最短路径。该系列函数即将不受官方支持。 以pgr_dijkstra()为例，它的参数有： 参数名 类型 说明 sql 文本 一个 SQL 查询。 source int4 起点的 ID。 target int4 终点的 ID。 directed boolean 如果地图是有向的，那么为ture。 has_rcost boolean 如果为true，SQL 查询的reverse_cost会被用来计算代价值。 其中 SQL 查询形如 1SELECT id, source, target, cost [,reverse_cost] FROM edge_table 返回列有： 列名 类型 说明 id int4 边的 ID。 source int4 起点的 ID。 target int4 终点的 ID。 cost float 边的代价值。为负则不考虑此边 reverse_cost 可选 边的往返代价值。只在directed和has_rcost参数为true时使用。 但是 pgRouting 提供的函数，只支持从路网数据的一个节点到另一个节点，也就是不支持任意两点间的最短路径。我们需要自己撰写函数来实现这一点。对于两个点 $ p_1,p_2 $，求解其间最短路径 $ p_1p_2$ 实现的思路如下： 找到 $ p_1,p_2 $ 最近的线段 $ l_1, l_2$ 找到 $ l_1 $ 的终点 $p_t$（即target值），和 $ l_2 $ 的起点 $p_s$（即source值）。 求解从target到source的最短路径 $ p $。 将 $ p $ 补上或删除 $ p_1p_t $ 和 $ p_sp_2 $ 两段。 由于在 PIF 中， 要求解路径的点是两个状态值，都在路网上，因此，在搜索最近路段时，搜索范围可放小一点，如 1 m。 根据博客，具体函数实现如下（做了一些修改）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485CREATE OR REPLACE FUNCTION \"public\".\"pif_getpathbetweenpoints\"(\"startx\" float8, \"starty\" float8, \"endx\" float8, \"endy\" float8) RETURNS TABLE(\"shortest_path\" \"public\".\"geometry\", \"path_cost\" float8) AS $BODY$declare tbl VARCHAR := 'road'; v_point1 geometry := st_transform(st_setsrid(ST_Point(startx, starty), 4326), 3857); v_point2 geometry := st_transform(st_setsrid(ST_Point(endx, endy), 4326), 3857); v_startLine geometry;--离起点最近的线 v_endLine geometry;--离终点最近的线 v_startTarget integer;--距离起点最近线的终点 v_endSource integer;--距离终点最近线的起点 v_statpoint geometry;--在v_startLine上距离起点最近的点 v_endpoint geometry;--在v_endLine上距离终点最近的点 v_res geometry;--最短路径分析结果 v_perStart float;--v_statpoint在v_res上的百分比 v_perEnd float;--v_endpoint在v_res上的百分比 v_shPath geometry;--最终结果 tempnode float; begin --查询离起点最近的线 select geom, target from road where ST_DWithin(geom, v_point1, 3) order by ST_Distance(geom, v_point1) limit 1 into v_startLine ,v_startTarget; --查询离终点最近的线 select geom, source from road where ST_DWithin(geom, v_point2, 3) order by ST_Distance(geom, v_point2) limit 1 into v_endLine,v_endSource; --如果没找到最近的线，就返回null if (v_startLine is null) or (v_endLine is null) then return; end if ; select ST_ClosestPoint(v_startLine, v_point1) into v_statpoint; select ST_ClosestPoint(v_endLine, v_point2) into v_endpoint; --最短路径 execute 'SELECT st_linemerge(st_union(b.geom)) ' || 'FROM pgr_kdijkstraPath( ''SELECT gid as id, source, target, cost FROM road '',' ||v_startTarget || ', ' ||'array['||v_endSource||'] , false, false ) a, ' || tbl || ' b WHERE a.id3=b.gid GROUP by id1 ORDER by id1' into v_res ; --如果找不到最短路径，就返回null --if(v_res is null) then -- return null; --end if; --将v_res,v_startLine,v_endLine进行拼接 select st_linemerge(ST_Union(array[v_res,v_startLine,v_endLine])) into v_res; select ST_LineLocatePoint(v_res, v_statpoint) into v_perStart; select ST_LineLocatePoint(v_res, v_endpoint) into v_perEnd; if(v_perStart &gt; v_perEnd) then tempnode = v_perStart; v_perStart = v_perEnd; v_perEnd = tempnode; end if; --截取v_res SELECT ST_LineSubString(v_res,v_perStart, v_perEnd) into v_shPath; RETURN QUERY SELECT st_transform(v_shPath, 4326), st_length(v_shPath);end$BODY$ LANGUAGE plpgsql VOLATILE COST 100 ROWS 1000 修改的地方： 固定了要查询的表。 将结果转换为 WGS84 坐标系。 在返回路径的同时返回了整个路径的长度。 Python 调用函数的编写与之前类似，Python 调用函数的实现如下： 123456789101112131415def getPaths(self, s1: State, s2: State): ''' 获取两个状态之间的路径 利用ArcPy获取路网上两点之间的最短路径 ''' # 创建要素 if s1.link_id == s2.link_id: return [] cur = self.conn.cursor() # type: psycopg2.extensions.cursor cur.execute(\"SELECT * FROM PIF_GetPathBetweenPoints(%s, %s, %s, %s)\", (s1.gps_pos.lng, s1.gps_pos.lat, s2.gps_pos.lng, s2.gps_pos.lat)) (linestring, cost) = cur.fetchone() # type: LineString path = [((p1.x, p1.y), (p2.x, p2.y)) for (p1, p2) in zip(linestring[1:-2], linestring[2:-1])] del cur return [(s1, [s1.link_id] + path + [s2.link_id], s2, cost)] 路径结果后处理在 PIF 核心库中，对两个车辆状态 $ x_i^{t} \\in \\mathbf{x}^{t} ,x_j^{t+1} \\in \\mathbf{x}^{t+1} $ 中间的路径 $ p_i $ 有要求。即 $ x_i^{t} $ 所在的路段的 ID 和 $x_j^{t+1}$ 所在路段的 ID 分别和 $ p_i $ 第一个路段的 ID 和 最后一个路段的 ID 相同。在不直接使用路段的 ID 作为最短路径搜索的返回值时，我们需要做一些处理。 产生这个问题原因，是 PIF 库的示例代码中，采用 $ ((x_S, y_S), (x_T, y_T)) $ 来表示 $ x_i^{t} $ 所在的路段 ID。若记获取某个状态值所在路段的 ID 的函数是 $ \\mathbf{id}(x) $，则要求 $ \\mathbf{id}(x_i^{t}) = \\overrightarrow{ST} = (p_i)_1 $，$ S, T $ 是路段的起点和终点。同理，$ \\mathbf{id}(x_i^{t}) = \\overrightarrow{ST} = (p_i)_{-1} $（$(p_i)_{-1}$ 表示最后一个搜索到的路径的最后一个路段）。 对于起始状态，理论上共有 6 种可能。如下图所示。记起始状态点为 $X$，其可能的 6 种情况分别为 $ \\left\\lbrace x_1, x_2, \\cdots, x_6 \\right\\rbrace $，其所在路段 $ \\mathbf{l} = \\overrightarrow{ST}$ 起点为 $S$，终点为 $T$，匹配到的整个路径为 $ P $。记符号 $ \\lnot \\mathbf{L} = \\overrightarrow{TS} $。 对于每个 $ X \\in \\left\\lbrace x_1, x_2, \\cdots, x_6 \\right\\rbrace $ $ X = x_1 \\neq S \\neq T \\wedge T = P_2 $ ：这是最一般的情况。只需令 $ P = \\left\\lbrace S \\right \\rbrace \\cup P $ 即可。 $ X = S \\wedge T = P_2 $ ：此种情况无需处理。 $ X = T \\wedge S \\neq P_2 $ ：令 $ P = \\left\\lbrace S \\right \\rbrace \\cup P $。 $ X = x_1 \\neq S \\neq T \\wedge S = P_2 $ ：令 $ \\mathbf{id}(X) = \\lnot \\mathbf{l} $。 $ X = S \\wedge T \\neq P_2 $ ：令 $ P = \\left\\lbrace T \\right \\rbrace \\cup P $，且 $ \\mathbf{id}(X) = \\lnot \\mathbf{l} $。 $ X = T \\wedge S = P_2 $ ：令 $ \\mathbf{id}(X) = \\lnot \\mathbf{l} $。 对于结束状态，可能的情况如下图。 处理方法可与上同理。 由于 pgRouting 的问题，好像会给求得的路径按照坐标大小排个序？我目前遇到过一次，因此，在进行上述处理之前，判断一下，起始状态和结束状态的坐标值是不是分别和路径的第一个点和最后一个点相同，如果不是，把路径反过来。 在理论上，上述 6 种情况是合理的。但是在实际运行过程中，竟然产生了 $$ X = x_1 \\neq S \\neq T \\wedge T = P_2 \\wedge S = P_2 $$ 的情况，因此还需要做一个处理。如果上述 6 种情况都不满足，视为没找到路径。 利用 ArcPy 实现调用 PIF 算法","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[{"name":"路网速度","slug":"路网速度","permalink":"http://hpdell.github.io/tags/路网速度/"}]},{"title":"使用TypeScript编写爬虫","slug":"crawler-cheerio-ts","date":"2017-12-06T21:23:28.000Z","updated":"2019-01-22T14:33:19.058Z","comments":true,"path":"编程/crawler-cheerio-ts/","link":"","permalink":"http://hpdell.github.io/编程/crawler-cheerio-ts/","excerpt":"我们需要的数据多种多样，不可能什么都买，就算有钱，有的数据也不一定能买到。这个时候要获取这些数据，就要靠爬虫了。 爬虫界大佬很多，开源库和框架数不胜数。理论上，凡是能方便连接互联网的编程语言，都适合用来写爬虫，比如C#、Java、JavaScript、Python等，当然还有用R、Matlab这些有点专业特色的语言写爬虫的，甚至用curl和Bash都可以写爬虫，只是好像较少听说过有用C++写爬虫的。我分别用过C#这种编译语言（Java应该类似）和JavaScript这种脚本语言写过多款爬虫，个人总结起来两种语言各有特色： 编译语言每次修改爬虫都要编译，我电脑比较渣，每次编译都要花点时间。但是可以轻松通过类型检查，保证每次GET参数的正确、返回值的直接解析等非常使用的功能。 脚本语言每次修改就可以直接运行了，但是填参数的时候就比较头疼了，需要反复检查有哪些参数、该填什么值，保证请求参数的格式正确。 自从学会了TypeScript之后，我个人就比较喜欢JavaScript和TypeScript语言，结合Node.js，可以达到比较好的写爬虫的效果，结合了编译语言和脚本语言共有的特点。只是搞得脚本有点复杂了，需要声明很多类型，指定变量类型……其实也是一个挺复杂的工作。虽然有点不像脚本，不够简洁，但能够提供类型检查还是省了不少事。 下面记录一下这次使用TypeScript编写爬虫的过程，以备后用。","text":"我们需要的数据多种多样，不可能什么都买，就算有钱，有的数据也不一定能买到。这个时候要获取这些数据，就要靠爬虫了。 爬虫界大佬很多，开源库和框架数不胜数。理论上，凡是能方便连接互联网的编程语言，都适合用来写爬虫，比如C#、Java、JavaScript、Python等，当然还有用R、Matlab这些有点专业特色的语言写爬虫的，甚至用curl和Bash都可以写爬虫，只是好像较少听说过有用C++写爬虫的。我分别用过C#这种编译语言（Java应该类似）和JavaScript这种脚本语言写过多款爬虫，个人总结起来两种语言各有特色： 编译语言每次修改爬虫都要编译，我电脑比较渣，每次编译都要花点时间。但是可以轻松通过类型检查，保证每次GET参数的正确、返回值的直接解析等非常使用的功能。 脚本语言每次修改就可以直接运行了，但是填参数的时候就比较头疼了，需要反复检查有哪些参数、该填什么值，保证请求参数的格式正确。 自从学会了TypeScript之后，我个人就比较喜欢JavaScript和TypeScript语言，结合Node.js，可以达到比较好的写爬虫的效果，结合了编译语言和脚本语言共有的特点。只是搞得脚本有点复杂了，需要声明很多类型，指定变量类型……其实也是一个挺复杂的工作。虽然有点不像脚本，不够简洁，但能够提供类型检查还是省了不少事。 下面记录一下这次使用TypeScript编写爬虫的过程，以备后用。 库的使用主要使用了下面两个库： web-request cheerio WebRequest：同步化的request请求为什么要用await同步化request请求呢？不仅仅是因为await关键字是TypeScript和新JavaScript标准的特性，其实有很多比较好的用途： 避开JavaScript“回调大坑”。我个人还挺喜欢JavaScript以回调的方式异步化同步操作，曾经在爬虫的时候写了一个全回调的爬虫，fs库中有同步版本的函数都没有用其同步版本，全都是异步版本。事实证明，在高速爬虫的时候，使用异步版本的函数确实提高了爬虫效率。但是，编写起来那个痛苦啊。如果需要从返回的值里面判断还有没有下一页了，就要不停地递归啊。这真的是回调大坑，难读、难写、难调试。以至于后来再写爬虫，都避免爬虫过程中判断是否有下一页，都是提前算好有多少页，然后硬编码的，这样反而会节省很多时间。但是使用同步化的过程就比较好实现了。 减少因JavaScript的回调和闭包造成的错误。再爬虫的时候，为了防反爬，最简单的办法是人工设定等待时间，让爬虫慢一点。由于JavaScript回调的特点，笔者多次尝试，发现只能使用setInterval()函数实现。但是使用TypeScirpt的await关键字，可以直接编写一个delay()函数，让程序等待。 这个库的大多数用法和request库差不多，配置也是直接采用的request库的配置，只是可以以同步的方式编写异步代码，姑且称之为“同步化”把。例如，获取一个get请求的相应就是： 12import * as WebRequest from 'web-request'var list_response = await WebRequest.get(`$&#123;site.url&#125;/pg$&#123;i + 1&#125;/`); 这里面使用site.url变量存储要访问的网页的基本地址，后面代表了页数。 全局配置的方法也和request库差不多，只是不需要返回一个新的request对象 1WebRequest.defaults(&#123;jar: true&#125;) 这里配置了使用Cookie。 我在上一次写高德API爬虫的时候，首次依靠同步化的request请求，完成了自动分析页数。瞬间感觉给人生节约了很多时间。 cheerio：提供jQuery Selector的解析能力在做前端的时候，定位一个元素，最常用的就是jQuery的Selector字符串。在Node.js中，可以使用cheerio这个简化的jQuery库来实现这一操作。 使用cheerio的方法很简单，就三步： 导入cheerio包： 1import * as cheerio from 'cheerio' 创建$对象（body变量代表了HTML响应正文） 1var $ = cheerio.load(body); 使用jQuery Selector即可（info_object.max_num是用于存储某个值的变量） 1info_object.max_num = parseInt($(\"body div.content div.leftContent div.resultDes.clear h2.total.fl span\").text().trim()); 一般大型网页的页面都非常复杂，仅仅依靠分析HTML源码，可能毫无头绪。但是，使用浏览器的开发人员工具就非常方便啦，不仅可以直接快速定位页面元素，还可以直接给出Selector表达式。 爬虫软件“八爪鱼”使用的是XPath表达式来定位页面元素（至少他的软件UI是这样做的）。我也尝试使用XPath，但是，由于HTML一些随意性，往往导致解析出错。而且，既然是网页，使用jQuery Selector表达式更简洁，更合适。 也有人说可以直接使用正则。确实可以，但是正则还要自己想是不是，如果有些复杂的正则还是挺费事的。用这个可以让开发人员工具自动分析，应该是更方便啊，除非你的电脑只有命令行。 当然，也不是什么都需要使用Selector表达式来定位的。如果只是像把坐标提出来，或者有一些其他特定的模式，直接使用正则表达式啊，比如 1var coord_string = /114.[0-9]*,30.[0-9]*/g.exec(body)[0]; 这样就提取出来了经纬度坐标，而这个坐标是隐藏在页面一个script标签中的一个变量里。 不过这种方式有点问题。如果页面上的某些标签是使用脚本添加的，可能开发人员工具给出的Selector路径，不一定能在HTML源代码里找到。但是如果很重要的数据是通过前端脚本渲染上去的，那肯定会在一个变量里面保存这些数据。这个时候直接揪出这个变量就可以了，万事大吉，还不用自己去提取HTML元素。 TypeScript编写爬虫既然使用TypeScript便写爬虫，那么就使用一些TypeScript的特性吧。首先应该就是TypeScript的类型化特点。当然还少不了await关键字。 API参数的类型化一个请求的请求参数往往是确定的，在一个开放API中都会给出。你所想要的数据类型是固定的，这个要看你的需求。类型化编写爬虫的方式，就是保证这两个过程不出错。 例如，在利用高德API获取POI的时候，参数在文档中明确指出了（高德地图API文档）。我们如果照着这样的文档，编写一个接口或者一个类，可以实现一些自动化功能。同样，返回结果也可以编写一个类型，直接在构造函数中实现一些对结果的处理。 例如，对高德搜索的API进行类型化。首先创建一个接口，表示一些除了key之外的参数 123456789101112131415161718/** 输出结果的格式 */export enum GaodePoiOutput &#123; JSON, XML&#125;/** 接口参数类型 */export interface IGaodePoiApi &#123; keywords: string[]; types: string[]; city?: string; citylimit?: boolean; children?: number; offset?: number; page?: number; building?: number; floor?: number; extensions?: string; output?: GaodePoiOutput;&#125; 然后，编写一个类，让其提供自动根据上述参数类型生成url的功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455export class GaodePoiApi &#123; baseurl: string; key: string; constructor(key: string) &#123; this.baseurl = \"http://restapi.amap.com/v3/place/text\" this.key = key; &#125; /** * 获取参数指定的POI * @param parameters 请求参数 */ getUrl(parameters: IGaodePoiApi): string &#123; var url = `$&#123;this.baseurl&#125;?key=$&#123;this.key&#125;`; for (var key in parameters) &#123; if (parameters.hasOwnProperty(key)) &#123; switch (key) &#123; case \"keywords\": if (parameters.keywords.length &gt; 0) &#123; url += `&amp;$&#123;key&#125;=`; url += parameters.keywords[0] for (var index = 1; index &lt; parameters.keywords.length; index++) &#123; var element = parameters.keywords[index]; url += `|$&#123;parameters.keywords[index]&#125;`; &#125; &#125; break; case \"types\": if (parameters.types.length &gt; 0) &#123; url += `&amp;$&#123;key&#125;=`; url += parameters.types[0] for (var index = 1; index &lt; parameters.keywords.length; index++) &#123; var element = parameters.keywords[index]; url += `|$&#123;parameters.keywords[index]&#125;` &#125; &#125; break; case \"output\": url += `&amp;$&#123;key&#125;=`; switch (parameters.output) &#123; case GaodePoiOutput.XML: url += \"XML\"; break; default: url += \"JSON\"; &#125; default: url += `&amp;$&#123;key&#125;=`; url += `$&#123;parameters[key]&#125;`; break; &#125; &#125; &#125; return url; &#125;&#125; 这样直接调用GaodePoiApi对象的getUrl()函数即可生成需要的请求。 为什么不用request库的qs配置参数呢？这个参数其实非常坑，在高德API、百度API这种特别复杂的请求参数要求下，往往会出现问题。例如，如果一个参数可以是一个数组，你却不能直接把这个参数的值写成数组，这样会出现问题，只能手动利用将其变成字符串。我一开始使用的是querystring.stringify()函数，直接将qs对象序列化成字符串，但是后来发现还是有问题。但是使用TypeScript这样做之后，就觉得更加合理，一些复杂的参数格式也更加可控。 请求结果的类型化开放API的示例如在爬取高德地图API的时候，返回一个JSON时，可以直接将其指定一个类型，方便后面的操作。例如： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** 高德POI搜索结果模型 */export interface IGaodePoiSearchResultModel &#123; status: string; info?: string; infocode?: string; count?: string; pois?: IGaodePoiModel[]; suggestion?: IGaodePoiSearchSuggestionsModel[];&#125;/** 高德地图API */export class GaodePoi &#123; id: string; name: string; typecode: string; biz_type: any[]; address: string; gjclng: number; gjclat: number; wgslng: number; wgslat: number; tel: string; distance: any[]; biz_ext: any[]; pname: string; cityname: string; adname: string; importance: any[]; shopid: any[]; shopinfo: string | number; poiweight: any[]; constructor(parameters: IGaodePoiModel) &#123; // 复制属性 this.id = parameters.id; this.name = parameters.name; this.typecode = parameters.typecode; this.biz_type = parameters.biz_type; this.address = parameters.address; this.tel = parameters.tel; this.distance = parameters.distance; this.biz_ext = parameters.biz_ext; this.pname = parameters.pname; this.cityname = parameters.cityname; this.adname = parameters.adname; this.importance = parameters.importance; this.shopid = parameters.shopid; this.shopinfo = parameters.shopinfo; this.poiweight = parameters.poiweight; // 计算坐标 var coords = parameters.location.split(\",\"); this.gjclng = parseFloat(coords[0]) this.gjclat = parseFloat(coords[1]) var wgs = coordtransform.gcj02towgs84(this.gjclng, this.gjclat) this.wgslng = wgs[0]; this.wgslat = wgs[1]; &#125; static getFields(): string[] &#123; return [ \"id\", \"name\", \"typecode\", \"biz_type\", \"address\", \"gjclng\", \"gjclat\", \"wgslng\", \"wgslat\", \"tel\", \"distance\", \"biz_ext\", \"pname\", \"cityname\", \"adname\", \"importance\", \"shopid\", \"shopinfo\", \"poiweight\" ] &#125;&#125; 这里面在构造函数中，调用了坐标转换库，转换了获取到的坐标。这个过程在获取结果时，在构造的过程中自动调用。 具体程序示例请参考：download-gaode-poi HTML页面的示例如果不是爬开放API，类型化也有一定的作用。例如爬取列表的时候，或者详细信息的时候，可以知道哪些属性时需要爬的，以及还有哪些属性没有爬下来。例如这段类型的声明 123456789101112131415161718192021222324export class ErshoufangListItem &#123; id: string; title: string; link: string; property: string; propertylink: string; tags: Array&lt;string&gt;; total_price: number; unit_price: number; type_time: string; constructor(self?: ErshoufangListItem) &#123; this.tags = new Array&lt;string&gt;(); if (self) &#123; this.title = self.title; this.link = self.link; this.property = self.property; this.propertylink = self.propertylink; this.tags = self.tags; this.total_price = self.total_price; this.unit_price = self.unit_price; this.type_time = self.type_time; &#125; &#125;&#125; 对应了下面这个列表页面中所需要提取的数据 在爬取页面的时候，按照这个类型中声明的属性进行爬取即可。这一点可以用于多人协作中，一个人负责确定所要爬取的数据的原型（声明这个类），另一个人便写爬虫，其他人按照这个类型对数据进行分析。 延时函数编写如果想让程序等待一定时间再继续爬取，setInterval()函数是可以使用的，但是又容易掉到回调坑里面。如果你再一个请求得到返回结果后又发起了一系列请求，这样两套setInterval()是统一不起来的，各计各的时间（因为request也用的是回调）。这个时候用TypeScript的await关键字调用一个延时函数（起名为delay()）是再好不过的。 delay()函数如下： 1234567/** * 延时函数 * @param times 延时时间 */function delay(times: number): Promise&lt;void&gt;&#123; return new Promise&lt;void&gt;((resolve, reject)=&gt;&#123;setTimeout(()=&gt;resolve(), times)&#125;);&#125; 使用时直接用await关键字“调用”即可 1await delay(10000); “前端爬虫”的后台搭建像百度地图API这种开放平台，有的时候JavaScript API提供的功能比Web服务API提供的功能多。例如，JavaScript API提供了“商圈”数据获取的功能。如果我们要爬取商圈数据，那就只在HTML页面中，调用这套API，将获取到的数据，通过Ajax发送到服务器上。此时要求服务器需要提供上传数据的接口，一旦这个接口被访问，服务器将前端上传的数据保存到文件中即可。 之所以这样做，是因为浏览器一般没有直接操作本地文件的能力，不能再获取到数据之后直接保存成文件。如果真要直接保存，那可能只能保存成cookie或者“本地存储”之类的东西？这样又不是很好用。 这样一个爬虫的分工就更明显了。前端工程师可以在前端设计页面如何自动调用API进行数据获取并提交，后端工程师设计服务器接口以进行数据的接收、处理和存储。 例如在编写这个商圈数据爬虫的过程中，百度给的示例页面是这样的： 使用的是百度提供的CityList类，包含两个方法： getBussiness()：获取商圈数据。 getSubAreaList()：获取下级的区域列表。 通过前端不断调用getBussiness()方法，即可获取到不同商圈的参数。 123456789101112131415161718192021222324252627282930313233for (let j = 0; j &lt; all_business.length; j++) &#123; const element = all_business[j]; console.log(element, \"商圈数据\"); await new Promise(function (resolve, reject) &#123; cityList.getBusiness(element, async function (json) &#123; await new Promise(function (resolve, reject) &#123; $.ajax(&#123; url: \"/upload/businessCircle\", type: \"POST\", data: &#123; body: JSON.stringify(&#123; name: element, business: json, city: \"武汉市\" &#125;) &#125;, success: function (body) &#123; resolve(); &#125;, error: function () &#123; reject(); &#125; &#125;) &#125;) resolve(); &#125;) &#125;) await new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve() &#125;, 1000) &#125;)&#125; 这段程序代码中： 由于ES6带来了await，前端现在也可以使用这种方式来使异步执行的程序同步化。但同样要求在async修饰的函数中才能使用await关键字。 all_business是所有商圈的名字。不同城市可能有相同名字的商圈，比如“中山公园”，这时可以根据返回结果中商圈的“城市”字段在判断。 JSON.stringify()POST参数是“Key-Value”模式的，因此一个键对应一个值，这个值用字符串形式。如果直接传入一个对象，会被转换成多个键值对的形式。所以遇到JS对象，就要用JSON.stringify()函数将其变成字符串，在后台再用JSON.parse()函数解析。 POST参数可以使用TypeScript的interface进行建模，这就需要浏览器中的脚本也使用TypeScript编写，然后编译。对于前端来说使用TypeScript的意义可能不大，因为很多前端库没有TypeScript的声明文件。但是前端工程师可以将自己所采用的POST参数模型交给后端工程师，后端工程师按照这个模型进行处理。 在后端，建立一个接受POST请求的服务，比如我用Express搭建的服务器，提供了这样一个POST接口： 123456789101112131415161718192021222324/** * 浏览器提交商圈 * @param req 请求 * @param res 响应 * @param next 后处理函数 */function postBusinessCircle(req: express.Request, res: express.Response, next: express.NextFunction) &#123; var data: &#123;name: string, city: string, business: BusinessCircle[]&#125; = JSON.parse(req.body.body); fs.writeFile(`data/BusinessCircle/$&#123;data.name&#125;.json`, JSON.stringify(&#123; name: data.name, business: data.business.filter(x =&gt; x.city === data.city) &#125;), (err) =&gt; &#123; if (err) console.log(err); else &#123; console.log(`$&#123;data.name&#125;写文件完成`); res.send(\"success\") &#125; &#125;)&#125;var router = express.Router();router.post(\"/businessCircle\", postBusinessCircle)module.exports = router; 即可接收前端通过POST参数上传的数据。 具体程序示例请参考：baidu-business-circle。 其他的话抓包工具要爬虫一定无法避免抓包。一般浏览器的开发人员工具又抓包的功能，同样也可以使用一些抓包工具来抓包。我比较喜欢使用抓包工具Fiddler。 使用浏览器自带的抓包工具，只能在当前页面抓包，而且如果新弹出了一个窗口，往往需要打开抓包工具后刷新一下页面才能抓到包。抓包的结果不能保存，不太方便。 使用Fiddler抓包就比较有优势，可以克服上述问题。但是Fiddler抓包范围太广，有些其他程序的http/https请求也会被抓到，因此抓包的结果可能要多很多。这个时候就要仔细分析哪些包是需要的，哪些包是不需要的。分析起来难度增大俩。 其他抓包工具我还没有试过，用过Fiddler之后感觉确实挺好用的，所以就没有试其他的了。 Fiddler还可以抓手机上的包，只需要设置代理即可，我曾经用这种方法抓了参考消息App的包，分析出它的API。如果一个手机软件用的是HTTPS协议，装一下Fiddler的证书即可。当然这时最好还是在安卓模拟器里面安装，以防个人信息无意中泄露。 SourceMap选项如果使用VSCode编写的话，可以直接调试。直接调试JavaScript是可以的，但是如何调试TypeScript呢？毕竟tsc编译生成的JS脚本太复杂了。 这需要在tsconfig.json文件和.vscode/launch.json中，分别开启sourceMap选项和sourceMaps选项。 123456789// tsconfig.json&#123; \"compilerOptions\": &#123; \"lib\": [ \"es2015\" ], \"sourceMap\": true &#125;&#125; 12345678910111213141516171819// .vscode/launch.json&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ &#123; \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"$&#123;file&#125;\", \"sourceMaps\": true, \"outFiles\": [ \"$&#123;workspaceFolder&#125;/**/*.js\" ] &#125; ]&#125; Visual Studio Code 的插件VSCode有一个“JSON to TS”的插件，在使用起来非常方便。这个插件可以根据剪贴板或JSON文件中的JSON字符串，按照其格式，生成对应的TypeScript Interface。这样，如果爬取一些给出了示例JSON数据的开放API，或者是前端工程师提供的示例数据，都可以直接使用这个插件生成Interface，非常方便开发。 不过这样生成的Interface也不是万能的，需要手动修改一些地方。如一些Interface的名字等。 暂时先记录到这里了。如果日后发现有一些需要补充的还会再添加上。如有错误欢迎大家指正。","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://hpdell.github.io/tags/爬虫/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://hpdell.github.io/tags/TypeScript/"}]},{"title":"手机中的信息安全","slug":"information-security-on-mobile","date":"2017-11-28T19:45:24.000Z","updated":"2019-01-22T14:33:19.086Z","comments":true,"path":"其他/information-security-on-mobile/","link":"","permalink":"http://hpdell.github.io/其他/information-security-on-mobile/","excerpt":"","text":"","categories":[{"name":"其他","slug":"其他","permalink":"http://hpdell.github.io/categories/其他/"}],"tags":[{"name":"课程","slug":"课程","permalink":"http://hpdell.github.io/tags/课程/"}]},{"title":"WPF 给列表加上自动编号","slug":"list-with-number","date":"2017-08-24T17:56:10.000Z","updated":"2019-01-22T14:33:19.114Z","comments":true,"path":"编程/list-with-number/","link":"","permalink":"http://hpdell.github.io/编程/list-with-number/","excerpt":"前言给 WPF 列表添加自动编号是个非常头疼的问题。综合网上的解决方案，有几种： 使用数据绑定。即给数据对象加入一个表示编号的属性，利用数据绑定显示编号。此方法实现方便，但是难以自动更新。 使用代码。在网上看到了这样一种解决方法，文章很多，比如这里，看起来比较麻烦，我们目标是寻找一种纯 XAML 的解决方案。 还有一个使用 VB.Net 写的代码示例（WPF中给listboxItem加上序号标签），声称可以。但是我不太了解 VB，不清除具体情况。 还有一个方案看起来是非常简单的，也是我所采用的解决方案。最早没有成功实现，后来参考了《WPF 编程宝典》才成功实现。但是现在一时半会儿找不到了。","text":"前言给 WPF 列表添加自动编号是个非常头疼的问题。综合网上的解决方案，有几种： 使用数据绑定。即给数据对象加入一个表示编号的属性，利用数据绑定显示编号。此方法实现方便，但是难以自动更新。 使用代码。在网上看到了这样一种解决方法，文章很多，比如这里，看起来比较麻烦，我们目标是寻找一种纯 XAML 的解决方案。 还有一个使用 VB.Net 写的代码示例（WPF中给listboxItem加上序号标签），声称可以。但是我不太了解 VB，不清除具体情况。 还有一个方案看起来是非常简单的，也是我所采用的解决方案。最早没有成功实现，后来参考了《WPF 编程宝典》才成功实现。但是现在一时半会儿找不到了。 代码实现《WPF 编程宝典》中介绍了“条纹列表”样式的实现。样子大概如下： 条纹列表实现条纹列表，需要用到 ListBox/ListView 控件的 AlternationCount 属性。MSDN对该属性的解释如下： 获取或设置 ItemsControl 中的交替项容器的数目，该控件可使交替容器具有唯一外观。 交替项容器的效果，就是对每一个 ListBoxItem/ListViewItem 有一个 ItemsControl.AlternationIndex 属性，表示该项的交替位置。例如，如果对一个 ListBox/ListView 控件设置 AlternationCount 属性为 3，则每一项的索引号和交替项索引号如下： 列表索引 交替项索引 0 0 1 1 2 2 3 0 4 1 5 2 6 0 7 1 于是，根据交替项索引，就可以实现条纹列表。在数据模板中，使用 RelativeSource 找到当前数据所在的 ListBoxItem，使用 (ItemsControl.AlternationIndex) 属性获取其交替项索引，对不同的索引进行处理。或者在生成的项的样式模板中，使用触发器修改条目样式，原书代码如下： 编号列表将上述方法进行推广，即可得到编号列表。我们可以将 AlternationCount 属性设置为列表项目的总数，这样在 ItemsControl.AlternationIndex 属性中，就可以获取当前列表项在列表中的位置。 数据绑定在数据模板中，将一个 TextBlock 的 Text 属性绑定到该属性中，即可进行显示。 12&lt;TextBlock Text=\"&#123;Binding RelativeSource=&#123;RelativeSource Mode=FindAncestor, AncestorType=ListBoxItem&#125;, Path=(ItemsControl.AlternationIndex)\" /&gt; 转换器当然，该位置是从 0 开始的，一般我们习惯于从 1 开始。因此，需要一个转换器。既然使用了转换器，就可以自定义很多表示方法，如“周日”、“周一”……“周六”；“第1名”、“第2名”…… 例如如下设计的一个转换器： 12345678910111213141516171819202122class IntToLevelStringConverter : IValueConverter&#123; static string[] LevelString = &#123; \"第一级\", \"第二级\", \"第三级\", \"第四级\", \"第五级\" &#125;; public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#123; int levelRank = (int)value; if (levelRank &lt; LevelString.Length) &#123; return LevelString[levelRank]; &#125; else &#123; return null; &#125; &#125; public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) &#123; throw new NotImplementedException(); &#125;&#125; 使用图片指示等级或者使用图片指示等级，如 那么，XAML 代码中应创建一个 Image 控件，将其 Source 属性绑定到 ItemsControl.AlternationIndex 属性，利用转换器转换成对应图片的 URL。 XAML的代码： 123&lt;Image Source=\"&#123;Binding RelativeSource=&#123;RelativeSource Mode=FindAncestor, AncestorType=ListBoxItem&#125;, Path=(ItemsControl.AlternationIndex), Converter=&#123;StaticResource IntToIconStringConverter&#125;&#125;\"/&gt; 转换器的代码： 12345678910111213141516171819202122232425262728class IntToIconStringConverter : IValueConverter&#123; static string[] IconPath = &#123; \"pack://application:,,,/FGISClient.UIControls;component/Icon/FireHandle/1ji.png\", \"pack://application:,,,/FGISClient.UIControls;component/Icon/FireHandle/2ji.png\", \"pack://application:,,,/FGISClient.UIControls;component/Icon/FireHandle/3ji.png\" &#125;; public object Convert(object value, Type targetType, object parameter, CultureInfo culture) &#123; int levelRank = (int)value; if (levelRank &lt; IconPath.Length) &#123; return IconPath[levelRank]; &#125; else &#123; return null; &#125; &#125; public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) &#123; throw new NotImplementedException(); &#125;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"http://hpdell.github.io/tags/WPF/"},{"name":"XAML","slug":"XAML","permalink":"http://hpdell.github.io/tags/XAML/"}]},{"title":"WPF制作带居中三角形指示的Tooltip样式的Tooltip","slug":"WPF-Bootstrap-Tooltip","date":"2017-08-21T22:19:30.000Z","updated":"2019-01-22T14:33:19.058Z","comments":true,"path":"编程/WPF-Bootstrap-Tooltip/","link":"","permalink":"http://hpdell.github.io/编程/WPF-Bootstrap-Tooltip/","excerpt":"本文所要实现的目标样式如下图。 可以看到这个Tooltip能够分解为一个三角形和一个圆角矩形，而且三角形要居中显示。经过在网上的充分搜索，没有找到可以直接使用的解决方案，那么就自己动手设计一个。","text":"本文所要实现的目标样式如下图。 可以看到这个Tooltip能够分解为一个三角形和一个圆角矩形，而且三角形要居中显示。经过在网上的充分搜索，没有找到可以直接使用的解决方案，那么就自己动手设计一个。 布局框架既然要居中显示一个三角形，最方便的应该就是Gird布局了。因此使用XAML创建一个Grid布局。 12&lt;Grid x:Name=\"g\"&gt;&lt;/Grid&gt; 由于三角形和圆角矩形在某种程度上说是结合在一起的，因此无需设置行和列。所以这里使用一个Border来布局也是可以的。 内部布局我们希望使用三角形“盖住”一部分圆角矩形的边框，因此需要将三角形放置在圆角矩形的下方，才能实现遮盖的效果。 除此之外还有以下要求： 采用Canvas面板来绘制三角形，此面板需要水平居中对齐、垂直顶部对齐；假设三角形高为6，宽为12，为等腰三角形。 采用Border控件实现圆角矩形，需要有一定边框宽度和颜色，水平拉伸、垂直拉伸，且与Grid面板的上边缘有一定的边距，边距大小略小于三角形高，这样可以让三角形遮盖一段边框。 因此采用如下设计： 12345678910111213&lt;Grid x:Name=\"g\"&gt; &lt;Border CornerRadius=\"3\" BorderThickness=\"1\" BorderBrush=\"&#123;StaticResource TooltipBorderBrush&#125;\" HorizontalAlignment=\"Stretch\" VerticalAlignment=\"Stretch\" Background=\"White\" Margin=\"0,5,0,0\" Padding=\"8\"&gt; &lt;/Border&gt; &lt;Canvas HorizontalAlignment=\"Center\" VerticalAlignment=\"Top\" Height=\"6\" Width=\"12\"&gt; &lt;/Canvas&gt;&lt;/Grid&gt; 三角形绘制在一个Canvas面板中，使用Polygon绘制三角形，设置为白色。那么这个三角形三个点的坐标当然就是$(0,6)$、$(6,0)$、$(12,6)$了。这样就能绘制一个三角形，又遮盖一段圆角矩形的边框。 1&lt;Polygon Points=\"0,6 6,0 12,6\" StrokeThickness=\"0\" Fill=\"White\"/&gt; 三角形的边框不能直接使用属性进行设置了，否则三角形的底也会被绘制上边框，无法达到效果。我们可以绘制一段多段线（Polyline）来实现边框的绘制。同样还是设置上面三个点，但是对象类型改为Polyline。 123&lt;Polyline Points=\"0,6 6,0 12,6\" Stroke=\"&#123;StaticResource TooltipBorderBrush&#125;\" StrokeThickness=\"1\"/&gt; 此时三角形绘制完成。 注意：需要明确指定Canvas面板的宽度，此处为12。否则，三角形无法真正居中，而是最左边对齐到圆角矩形的中间。 圆角矩形的设置圆角矩形样式较好设置。内容的设置可以使用ContentPresenter，使得在使用时可以直接使用XAML代码来设置内容。该Presenter设置为水平居中、垂直居中即可。 1&lt;ContentPresenter VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/&gt; 整体代码1234567891011121314&lt;Grid x:Name=\"g\"&gt; &lt;Border CornerRadius=\"3\" BorderThickness=\"1\" BorderBrush=\"&#123;StaticResource TooltipBorderBrush&#125;\" HorizontalAlignment=\"Stretch\" VerticalAlignment=\"Stretch\" Background=\"White\" Margin=\"0,5,0,0\" Padding=\"8\"&gt; &lt;ContentPresenter VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/&gt; &lt;/Border&gt; &lt;Canvas HorizontalAlignment=\"Center\" VerticalAlignment=\"Top\" Height=\"6\" Width=\"12\"&gt; &lt;Polygon Points=\"0,6 6,0 12,6\" StrokeThickness=\"0\" Fill=\"White\"/&gt; &lt;Polyline Points=\"0,6 6,0 12,6\" Stroke=\"&#123;StaticResource TooltipBorderBrush&#125;\" StrokeThickness=\"1\"/&gt; &lt;/Canvas&gt;&lt;/Grid&gt; 可以将此段代码放置在自定义Tooltip样式的Template属性值下，实现通过样式进行设置。即 123456789101112131415161718192021222324252627282930313233&lt;Style x:Key=\"FGisToolTipStyle\" TargetType=\"ToolTip\"&gt; &lt;Setter Property=\"OverridesDefaultStyle\" Value=\"true\" /&gt; &lt;Setter Property=\"HasDropShadow\" Value=\"True\" /&gt; &lt;Setter Property=\"Foreground\" Value=\"#333333\" /&gt; &lt;Setter Property=\"FontSize\" Value=\"14\" /&gt; &lt;Setter Property=\"Placement\" Value=\"Bottom\"/&gt; &lt;Setter Property=\"Template\"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType=\"ToolTip\"&gt; &lt;Grid x:Name=\"g\"&gt; &lt;Border CornerRadius=\"3\" BorderThickness=\"1\" BorderBrush=\"&#123;StaticResource TooltipBorderBrush&#125;\" HorizontalAlignment=\"Stretch\" VerticalAlignment=\"Stretch\" Background=\"White\" Margin=\"0,5,0,0\" Padding=\"8\"&gt; &lt;ContentPresenter VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\"/&gt; &lt;/Border&gt; &lt;Canvas HorizontalAlignment=\"Center\" VerticalAlignment=\"Top\" Height=\"6\" Width=\"12\"&gt; &lt;Polygon Points=\"0,6 6,0 12,6\" StrokeThickness=\"0\" Fill=\"White\"/&gt; &lt;Polyline Points=\"0,6 6,0 12,6\" Stroke=\"&#123;StaticResource TooltipBorderBrush&#125;\" StrokeThickness=\"1\"/&gt; &lt;/Canvas&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt;&lt;/Style&gt; 也可以放置在自定义的用户控件中，作为控件使用。","categories":[{"name":"编程","slug":"编程","permalink":"http://hpdell.github.io/categories/编程/"}],"tags":[{"name":"WPF","slug":"WPF","permalink":"http://hpdell.github.io/tags/WPF/"},{"name":"XAML","slug":"XAML","permalink":"http://hpdell.github.io/tags/XAML/"}]}]}