<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>Python 多进程编程 | 我们在小孩和大人的转角盖一座城堡</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="hpdell"><meta name="designer" content="minfive"><meta name="keywords" content="undefined"><meta name="description" content="HPDell 的博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://hpdell.github.io/编程/py-multiprocess/index.html"><link rel="icon" type="image/png" href="/assets/img/avatar.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="HPDell 的个人博客"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart=""><div id="page-loading" class="page page-loading" style="background-image:url(undefined)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="HPDell 的个人博客" alt="HPDell 的个人博客"><img src="/assets/img/avatar.jpg" alt="HPDell 的个人博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/assets/img/header_cover.jpg" alt="Python 多进程编程"></div><header class="post__info"><h1 class="post__title">Python 多进程编程</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">HPDell</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-07-09</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Python/">Python</a></li></ul></div></div></header><div class="post__content"><p>Python 在处理大数据的时候，启用多进程是有效提高计算效率的手段。 Python 已经提供了非常好用的 multiprocess 包来支持多进程编程， 但是在多进程编程时仍然会遇到一些难以处理的问题，需要一些技巧来解决。 <a id="more"></a> 目录：</p><ul><li><a href="#python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%95%88%E7%8E%87%E7%9A%84%E6%8F%90%E5%8D%87">Python 多进程对效率的提升</a></li><li><a href="#python-%E5%BC%80%E5%90%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B">Python 开启多进程</a><ul><li><a href="#%E5%88%9B%E5%BB%BA-process-%E5%AF%B9%E8%B1%A1">创建 Process 对象</a><ul><li><a href="#%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0">构造参数</a></li><li><a href="#%E5%B1%9E%E6%80%A7">属性</a></li><li><a href="#%E6%96%B9%E6%B3%95">方法</a></li><li><a href="#%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B">调用示例</a></li></ul></li><li><a href="#%E5%B0%86%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89%E4%B8%BA%E7%B1%BB">将进程定义为类</a></li><li><a href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0pool">进程池（Pool）</a><ul><li><a href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E6%9E%84%E9%80%A0">进程池构造</a></li><li><a href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E6%96%B9%E6%B3%95">进程池方法</a></li><li><a href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B">进程池调用示例</a></li></ul></li></ul></li><li><a href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90">多进程共享资源</a><ul><li><a href="#%E9%94%81">锁</a><ul><li><a href="#%E4%BA%92%E6%96%A5%E9%94%81lock">互斥锁（Lock）</a></li><li><a href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81rlock">可重入锁（RLock）</a></li><li><a href="#%E6%9D%A1%E4%BB%B6%E9%94%81condition">条件锁（Condition)</a></li><li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore">信号量（Semaphore）</a></li></ul></li><li><a href="#%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">共享变量</a><ul><li><a href="#multiprocess-%E5%8C%85%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">multiprocess 包内置类型</a></li><li><a href="#%E9%80%9A%E8%BF%87-manager-%E5%88%9B%E5%BB%BA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F">通过 Manager 创建共享变量</a></li></ul></li></ul></li><li><a href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">进程间通信</a><ul><li><a href="#%E9%80%9A%E8%BF%87%E4%BA%8B%E4%BB%B6event%E9%80%9A%E4%BF%A1">通过事件（Event）通信</a></li><li><a href="#%E9%80%9A%E8%BF%87%E9%98%9F%E5%88%97queue%E9%80%9A%E4%BF%A1">通过队列（Queue）通信</a></li><li><a href="#%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93pipe%E9%80%9A%E4%BF%A1">通过管道（Pipe）通信</a></li></ul></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a><ul><li><a href="#tqdm-%E5%A4%9A%E8%BF%9B%E5%BA%A6%E6%9D%A1">tqdm 多进度条</a></li><li><a href="#windows-%E4%B8%8A-lock-%E7%9A%84%E9%97%AE%E9%A2%98">Windows 上 Lock 的问题</a></li></ul></li></ul><h1 id="Python-多进程对效率的提升"><a href="#Python-多进程对效率的提升" class="headerlink" title="Python 多进程对效率的提升"></a>Python 多进程对效率的提升</h1><p>一篇<a href="https://segmentfault.com/a/1190000007495352" target="_blank" rel="noopener">《Python 中单线程、多线程和多进程的效率对比实验》</a>的文章中提到：</p><blockquote><p>Python是运行在解释器中的语言，有一个全局锁（GIL）， 在使用多进程(Thread)的情况下，不能发挥多核的优势。 而使用多进程(Multiprocess)，则可以发挥多核的优势真正地提高效率。</p></blockquote><p>文章中对 Python 在多线程、多进程的效率进行了对比：</p><table><thead><tr><th>操作类型</th><th style="text-align:right">CPU 密集型</th><th style="text-align:right">IO 密集型</th><th style="text-align:right">网络请求密集型</th></tr></thead><tbody><tr><td>线性操作</td><td style="text-align:right">94.91824996469</td><td style="text-align:right">22.46199995279</td><td style="text-align:right">7.3296000004</td></tr><tr><td>多线程操作</td><td style="text-align:right">101.1700000762</td><td style="text-align:right">24.8605000973</td><td style="text-align:right">0.5053332647</td></tr><tr><td>多进程操作</td><td style="text-align:right">53.8899999857</td><td style="text-align:right">12.7840000391</td><td style="text-align:right">0.5045000315</td></tr></tbody></table><p>可见：</p><ol><li>多线程操作只在网络请求密集型操作中具有非常明显的优势，其开销小于多进程，可用于网络爬虫。</li><li>多进程操作在各种操作中都有效率提升，在 IO 密集型操作中的优势更大。</li></ol><p>最近在处理一套出租车数据，出租车数据量非常大，自己搭建数据库， 查询效率非常低。因此采用 Python 脚本进行处理，</p><h1 id="Python-开启多进程"><a href="#Python-开启多进程" class="headerlink" title="Python 开启多进程"></a>Python 开启多进程</h1><p>Python 中的 <code>multiprocess</code> 包提供了多进程支持。可以使用三种方法来创建进程。</p><h2 id="创建-Process-对象"><a href="#创建-Process-对象" class="headerlink" title="创建 Process 对象"></a>创建 Process 对象</h2><p>最简单的开启 Python 进程的方法，是直接构造 <code>multiprocess.Process</code> 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocess <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line">process = Process()</span><br></pre></td></tr></table></figure><h3 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h3><p><code>Process</code> 对象在构造时主要接收三个参数：</p><ul><li><code>target</code>：进程调用的函数；</li><li><code>args</code>：进程调用函数时给函数传递的参数，为一个元组；</li><li><code>name</code>：别名。</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>Process</code> 的类型有以下属性：</p><ul><li><code>daemon</code>：当这个属性设置为 <code>True</code> 时，子进程会随着主进程的结束而结束。否则，主进程结束后，子进程依然会继续进行；</li><li><code>exitcode</code>：进程在运行时为 None 、如果为 –N ，表示被信号 N 结束；</li><li><code>name</code></li><li><code>pid</code></li><li><code>authkey</code></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>Process</code> 有如下方法：</p><ul><li><code>start()</code>：调用 <code>start()</code> 函数时，子进程开始执行，主进程继续执行。</li><li><code>join()</code>：“<a href="https://www.cnblogs.com/lipijin/p/3709903.html" target="_blank" rel="noopener">阻塞当前进程，直到调用 join 方法的那个进程执行完，再继续执行当前进程。</a>”</li><li><code>run()</code>：当构造时如果没有制定 <code>target</code> 参数，那么 <code>start()</code> 方法默认执行 <code>run()</code> 函数。</li><li><code>is_alive()</code>：判断当前进程是否活动。</li></ul><h3 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocess <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work_fun</span><span class="params">(work_list)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distrib_works</span><span class="params">(work_list, process_num)</span>:</span></span><br><span class="line">    group_length = math.ceil(len(filename_list) / process_num)</span><br><span class="line">    <span class="keyword">return</span> [work_list[(i*group_length):((i+<span class="number">1</span>)*group_length)] <span class="keyword">for</span> i <span class="keyword">in</span> range(process_num)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">work_list = os.listdir(<span class="string">"../data"</span>)</span><br><span class="line">process_num = <span class="number">4</span></span><br><span class="line">group = distrib_works(work_list, process_num)</span><br><span class="line"></span><br><span class="line">process_list = [Process(target=work_fun, args=(g,)) <span class="keyword">for</span> g <span class="keyword">in</span> group_list]</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">    p.daemon = <span class="keyword">True</span></span><br><span class="line">    p.start()</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure><h2 id="将进程定义为类"><a href="#将进程定义为类" class="headerlink" title="将进程定义为类"></a>将进程定义为类</h2><p>利用 Python 面向对象的特性，我们可以创建一个类，继承 <code>Process</code> 类， 将一些数据直接在构造的时候保存下来，可以无需在调用的时候传入。 例如，当我们在多进程程序中使用 <code>tqdm</code> 库显示进度条时，会用到其 <code>position</code> 参数来指定当前进度条在控制台中显示的位置，这个参数的值，我们可以直接保存在进程类中， 无需调用的时候再传入。</p><p>将进程定义为类的方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocess <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    position = <span class="number">0</span></span><br><span class="line">    works = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, position, works)</span></span></span><br><span class="line"><span class="function">        <span class="title">Process</span>.<span class="title">__init__</span><span class="params">(self)</span></span></span><br><span class="line">        self.position = poisition</span><br><span class="line">        self.works = works</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>如果在构造函数中，调用的 <code>Process</code> 的构造函数没有指定 <code>target</code>， 进程同样默认执行 <strong><em>不带参数的 <code>run</code> 函数，即使你的 <code>run</code> 函数定义了形参！</em></strong></p><p>在创建进程时，只需要将原来调用的 <code>Process</code> 的构造函数，改为调用 <code>MyProcess</code> 的构造函数即可。 这种创建进程方式的实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocess <span class="keyword">import</span> Process, Lock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distrib_works</span><span class="params">(work_list: List[str], process_num)</span> -&gt; List[List[str]]:</span></span><br><span class="line">    group_length = math.ceil(len(work_list) / process_num)</span><br><span class="line">    <span class="keyword">return</span> [g <span class="keyword">for</span> g <span class="keyword">in</span> [work_list[(i*group_length):((i+<span class="number">1</span>)*group_length)] <span class="keyword">for</span> i <span class="keyword">in</span> range(process_num)] <span class="keyword">if</span> len(g) &gt; <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindTargetTaxiProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_files, index, lock, log_file)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self, target=find_target, args=(lock, log_file))</span><br><span class="line">        self.input_files = input_files</span><br><span class="line">        self.index = index</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_target</span><span class="params">(self, lock, log_file)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> self.input_files:</span><br><span class="line">            <span class="keyword">with</span> open(filename) <span class="keyword">as</span> in_file:</span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> tqdm(in_file, ncols=<span class="number">80</span>, position=self.index):</span><br><span class="line">                    cells = row.split(<span class="string">","</span>)</span><br><span class="line">                    <span class="keyword">if</span> int(cells[<span class="number">0</span>]) == <span class="number">11865</span>:</span><br><span class="line">                        print(row)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    LOG_FILE = <span class="string">r"E:\出租车点\上下车点\scripts\data\find_error.log"</span></span><br><span class="line">    lock = multiprocessing.Lock()</span><br><span class="line">    <span class="comment"># ROOT_DIR = "../data/201502/temp"</span></span><br><span class="line">    ROOT_DIR = <span class="string">r"E:\出租车点\201502\RawCSV"</span></span><br><span class="line">    INPUT_FILES = [os.path.join(ROOT_DIR, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(ROOT_DIR)]</span><br><span class="line">    GROUP_LIST = distrib_works(INPUT_FILES, <span class="number">4</span>)</span><br><span class="line">    PROCESS_LIST = [FineTargetTaxiProcess(element, i, lock) <span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(GROUP_LIST)]</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> PROCESS_LIST:</span><br><span class="line">        process.start()</span><br></pre></td></tr></table></figure><blockquote><p>这种定义为类的方式有一个好处，在用 VSCode 调试的时候，在子进程中打断点是无效的。 如果用这种方式，可以将调用的 <code>start()</code> 函数改为 <code>run()</code> 或其他实际进程执行的函数， 这样就可以调试进程内部了。当解决了 Bug 后，就可以换回 <code>start()</code> 函数并行执行。</p></blockquote><h2 id="进程池（Pool）"><a href="#进程池（Pool）" class="headerlink" title="进程池（Pool）"></a>进程池（Pool）</h2><p>可以发现，上面两种创建进程的方式，都是用到了一个 <code>distrib_works()</code> 函数来分配各个进程的任务。 这一过程可以被一个叫做进程池的类型代替。</p><h3 id="进程池构造"><a href="#进程池构造" class="headerlink" title="进程池构造"></a>进程池构造</h3><p>构造进程池的方法非常简单，导入 <code>Pool</code> 之后，直接构造 <code>Pool</code> 对象。 构造时可以指定最多的进程数量，默认是 CPU 核心数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocess <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line">p = Pool(process=<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="进程池方法"><a href="#进程池方法" class="headerlink" title="进程池方法"></a>进程池方法</h3><p><code>Pool</code> 类型主要有以下方法：</p><ul><li><code>apply_async()</code> 和 <code>apply()</code>：这两个函数都是让进程池开始执行任务，<code>apply_async()</code> 是非阻塞的（主进程继续执行），<code>apply()</code> 是阻塞的（主进程等待子进程执行完成后继续执行）。</li><li><code>close()</code>：关闭进程池，不再接收新任务。</li><li><code>join()</code>：<a href="http://www.cnblogs.com/kaituorensheng/p/4445418.html" target="_blank" rel="noopener">主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用。</a></li></ul><h3 id="进程池调用示例"><a href="#进程池调用示例" class="headerlink" title="进程池调用示例"></a>进程池调用示例</h3><p>将上面一段使用 <code>FindTargetTaxiProcess</code> 类编写的代码用 <code>Pool</code> 重写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocess <span class="keyword">import</span> Process, Pool, Lock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_target</span><span class="params">(in_file, lock, log_file)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename) <span class="keyword">as</span> in_file:</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> tqdm(in_file, ncols=<span class="number">80</span>, position=self.index):</span><br><span class="line">            cells = row.split(<span class="string">","</span>)</span><br><span class="line">            <span class="keyword">if</span> int(cells[<span class="number">0</span>]) == <span class="number">11865</span>:</span><br><span class="line">                <span class="keyword">with</span> lock:</span><br><span class="line">                    <span class="keyword">with</span> open(log_file, mode=<span class="string">"a"</span>) <span class="keyword">as</span> log:</span><br><span class="line">                        print(row, file=log)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    LOCK = multiprocessing.Lock()</span><br><span class="line">    LOG_FILE = <span class="string">r"E:\出租车点\上下车点\scripts\data\find_error.log"</span></span><br><span class="line">    ROOT_DIR = <span class="string">r"E:\出租车点\201502\RawCSV"</span></span><br><span class="line">    INPUT_FILES = [os.path.join(ROOT_DIR, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(ROOT_DIR)]</span><br><span class="line">    POOL = Pool(process=<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> INPUT_FILES:</span><br><span class="line">        POOL.apply_async(find_target, (f, LOCK, LOG_FILE))</span><br><span class="line">    POOL.close()</span><br><span class="line">    POOL.join()</span><br></pre></td></tr></table></figure><h1 id="多进程共享资源"><a href="#多进程共享资源" class="headerlink" title="多进程共享资源"></a>多进程共享资源</h1><p>当我们把多个任务分解到 $n$ 个进程上执行时，这 $n$ 个进程往往会存在某种共享的资源， 如共享一个控制台、文件系统、列表或字典。这里存在两个问题：</p><ul><li>当多个进程同时访问这些资源时，就会产生冲突。例如，两个进程同时对控制台输出文本，写入的结果可以错综复杂，并不是两段文本的顺序组合。</li><li>各个进程有自己的内存空间，变量无法共享。例如，当想要利用多个进程操作主进程的一个列表时，各个进程操作结束后，主进程仍然是原来的状态。</li></ul><p>这两个问题的解决，前者靠“锁”机制，后者靠“共享变量”机制。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>对于冲突的情况，当使用 tqdm 显示多个进度条时比较明显。在 Windows 上，由于 “tqdm 无法获取默认锁”，因此控制台输出会比较乱，下面是一段程序在 Windows 上运行的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">λ python3 find_errors.py</span><br><span class="line">Process 0: 0it [00:00, ?it/s]</span><br><span class="line">Process 1: 0it [00:00, ?it/s]</span><br><span class="line">Process 0: 273516it [00:00, 523719.79it/s]</span><br><span class="line">Process 0: 995883it [00:01, 510379.67it/s]</span><br><span class="line">Process 0: 1107387it [00:02, 510326.10it/s]</span><br><span class="line">Process 0: 1224813it [00:02, 512761.81it/s]</span><br><span class="line">Process 0: 3483799it [00:06, 539191.83it/s]</span><br><span class="line">Process 1: 3683852it [00:06, 571536.15it/s]</span><br><span class="line">Process 0: 3550015it [00:06, 540296.03it/s]</span><br><span class="line">Process 0: 3615558it [00:06, 540947.45it/s]</span><br><span class="line">Process 0: 3742521it [00:06, 542112.37it/s]</span><br></pre></td></tr></table></figure><p>而在 Linux 系统中的运行结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Process 0: 2045720it [00:03, 647073.52it/s]</span><br><span class="line">Process 1: 2092184it [00:03, 661530.01it/s]</span><br><span class="line">Process 2: 2065411it [00:03, 652446.31it/s]</span><br><span class="line">Process 3: 2093610it [00:03, 661782.04it/s]</span><br></pre></td></tr></table></figure><p>可见在访问共享资源的时候，加锁是非常有必要的。</p><h3 id="互斥锁（Lock）"><a href="#互斥锁（Lock）" class="headerlink" title="互斥锁（Lock）"></a>互斥锁（Lock）</h3><p><code>Lock</code> 属于“互斥锁”，即<a href="https://www.jb51.net/article/63508.htm" target="_blank" rel="noopener">保证在任一时刻，只能有一个线程访问该对象。</a> 通过 <code>Lock</code> 类型创建互斥锁后，将其传递到子进程内部，即可在子进程中使用。</p><p>使用 <code>Lock</code> 时，可以使用 <code>with</code> 语句加锁， <code>with</code> 语句块执行完成后自动解锁； 也可以通过其 <code>acquire()</code> 函数来加锁，使用 <code>release()</code> 函数解锁。</p><p>使用 <code>with</code> 语句进行加锁的示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> self.input_files:</span><br><span class="line">        <span class="keyword">with</span> open(filename, encoding=<span class="string">"GB2312"</span>) <span class="keyword">as</span> in_file:</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> tqdm(in_file):</span><br><span class="line">                cells = row.split(<span class="string">","</span>)</span><br><span class="line">                <span class="keyword">if</span> int(cells[<span class="number">0</span>]) == <span class="number">11865</span>:</span><br><span class="line">                    <span class="keyword">with</span> self.lock:</span><br><span class="line">                        <span class="keyword">with</span> open(TARGET_TAXI_FILE, mode=<span class="string">"a"</span>) <span class="keyword">as</span> log:</span><br><span class="line">                            print(row, file=log)</span><br></pre></td></tr></table></figure><blockquote><p>这段代码在 Windows 上运行时，子进程内部的 lock 和 主进程传递进去的 lock 的 id 值不相同。 但是在 Linux 系统上时相同的。因此 Windows 上这段代码有可能会出错。 不过当文件被一个进程打开时，是无法被另一个进程打开的，因此这段程序的结果倒没出什么错。</p></blockquote><h3 id="可重入锁（RLock）"><a href="#可重入锁（RLock）" class="headerlink" title="可重入锁（RLock）"></a>可重入锁（RLock）</h3><p>互斥锁可以解决简单的避免资源冲突的问题，但当一个线程加锁后仍需要再次访问共享资源时， 就形成了嵌套锁，而使用互斥锁时就形成了“死锁”问题。这时我们需要使用 <code>RLock</code> 类型， 即“可重入锁”。</p><blockquote><p>死锁的含义是：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象， 若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 避免死锁主要方法是正确有序的分配资源。</p></blockquote><p><code>multiprocess</code> 中的 <code>RLock</code> 类型与 <code>Lock</code> 类型的区别在于： <a href="https://blog.csdn.net/cnmilan/article/details/8849895" target="_blank" rel="noopener">RLock允许在同一线程中被多次申请。而 Lock 却不允许这种情况。</a> 因此，<a href="https://blog.csdn.net/cnmilan/article/details/8849895" target="_blank" rel="noopener">如果使用 <code>RLock</code> ，那么 acquire() 和 release() 必须成对出现</a>， 调用了几次 <code>acquire()</code>，就需要调用几次 <code>release()</code>。</p><h3 id="条件锁（Condition"><a href="#条件锁（Condition" class="headerlink" title="条件锁（Condition)"></a>条件锁（Condition)</h3><p>条件同步机制是指：线程 $B$ 等待特定条件 $C$ ，而另一个线程 $A$ 发出特定条件满足的信号 $C$ 。 $B$ 在收到信号 $C$ 时，继续执行。</p><p>可以通过“生产者-消费者”模型来理解这一过程。 生产者获取锁，生产一个随机整数，通知消费者并释放锁。 消费者获取锁，如果有整数则消耗一个整数并释放锁，如果没有就等待生产者继续生产。</p><p>示例代码如下（参考<a href="https://yoyzhou.github.io/blog/2013/02/28/python-threads-synchronization-locks/" target="_blank" rel="noopener">《Python 线程同步机制》</a>并进行修改）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, productList, condition)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.productList = productList  <span class="comment"># type: List</span></span><br><span class="line">        self.condition = condition  <span class="comment"># type: multiprocess.Condition</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            product = random.randint(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">with</span> self.condition:</span><br><span class="line">                print(<span class="string">"条件锁：被 生产者 获取"</span>)</span><br><span class="line">                self.productList.append(product)</span><br><span class="line">                print(<span class="string">f"生产者：产生了 <span class="subst">&#123;product&#125;</span>。"</span>)</span><br><span class="line">                print(<span class="string">"生产者：唤醒消费者线程"</span>)</span><br><span class="line">                self.condition.notify()</span><br><span class="line">                print(<span class="string">"条件锁：被 生产者 释放"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, productList, condition)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.productList = productList  <span class="comment"># type: List</span></span><br><span class="line">        self.condition = condition  <span class="comment"># type: multiprocess.Condition</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">with</span> self.condition:</span><br><span class="line">                print(<span class="string">"条件锁：被 消费者 获取"</span>)</span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                    <span class="keyword">if</span> self.productList:</span><br><span class="line">                        product = self.productList.pop()</span><br><span class="line">                        print(<span class="string">f"消费者：消费了 <span class="subst">&#123;product&#125;</span>"</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    print(<span class="string">"消费者：等待生产者"</span>)</span><br><span class="line">                    self.condition.wait()</span><br><span class="line">                print(<span class="string">"条件锁：被 消费者 释放"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    manager = multiprocessing.Manager()</span><br><span class="line">    productList = manager.list()</span><br><span class="line">    condition = multiprocessing.Condition()</span><br><span class="line">    process_producer = Producer(productList, condition)</span><br><span class="line">    process_customer = Customer(productList, condition)</span><br><span class="line">    process_producer.start()</span><br><span class="line">    process_customer.start()</span><br><span class="line">    process_producer.join()</span><br><span class="line">    process_customer.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行的部分结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">条件锁：被 生产者 获取</span><br><span class="line">生产者：产生了 47。</span><br><span class="line">生产者：唤醒消费者线程</span><br><span class="line">条件锁：被 生产者 释放</span><br><span class="line">条件锁：被 消费者 获取</span><br><span class="line">消费者：消费了 47</span><br><span class="line">条件锁：被 消费者 释放</span><br><span class="line">条件锁：被 消费者 获取</span><br><span class="line">消费者：等待生产者</span><br><span class="line">条件锁：被 生产者 获取</span><br><span class="line">生产者：产生了 100。</span><br><span class="line">生产者：唤醒消费者线程</span><br><span class="line">条件锁：被 生产者 释放</span><br><span class="line">消费者：消费了 100</span><br><span class="line">条件锁：被 消费者 释放</span><br><span class="line">条件锁：被 消费者 获取</span><br><span class="line">消费者：等待生产者</span><br><span class="line">条件锁：被 生产者 获取</span><br><span class="line">生产者：产生了 95。</span><br><span class="line">生产者：唤醒消费者线程</span><br><span class="line">条件锁：被 生产者 释放</span><br><span class="line">消费者：消费了 95</span><br><span class="line">条件锁：被 消费者 释放</span><br><span class="line">条件锁：被 消费者 获取</span><br><span class="line">消费者：等待生产者</span><br></pre></td></tr></table></figure><h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3><p>信号量是一个非负整数，所有通过它的进程都会将该整数减一， 当该整数值为零时，所有试图通过它的进程都将处于等待状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, current_process, Semaphore</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(s, i)</span>:</span></span><br><span class="line">    s.acquire()</span><br><span class="line">    print(current_process().name + <span class="string">"acquire"</span>);</span><br><span class="line">    time.sleep(i)</span><br><span class="line">    print(current_process().name + <span class="string">"release\n"</span>);</span><br><span class="line">    s.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = Semaphore(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = Process(target = worker, args=(s, i*<span class="number">2</span>))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure><h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><p>在多进程中，是无法直接使用全局变量作为共享变量的，因为不同进程具有不同的内存空间。 但是，共享变量也是不能避免的。Python 中也提供了一些创建共享变量的方法。</p><ul><li>Multiprocess 包内置类型</li><li>通过 Manager 创建共享变量</li></ul><h3 id="multiprocess-包内置类型"><a href="#multiprocess-包内置类型" class="headerlink" title="multiprocess 包内置类型"></a>multiprocess 包内置类型</h3><p>multiprocess 包提供了两种类型的共享变量：</p><ul><li><code>Value(typecode_or_type, *args, lock=True)</code>：表示一个值类型变量。</li><li><code>Array(typecode_or_type, size_or_initializer, *, lock=True)</code>：表示一个数组。这种创建数组的方式能力比较有限，它不支持除了 C 数据类型以外的类型。</li></ul><p><code>typecode_or_type</code> 描述了元素的类型，可取值是：</p><table><thead><tr><th>typecode</th><th>type</th></tr></thead><tbody><tr><td>‘c’</td><td>ctypes.c_char</td></tr><tr><td>‘u’</td><td>ctypes.c_wchar</td></tr><tr><td>‘b’</td><td>ctypes.c_byte</td></tr><tr><td>‘B’</td><td>ctypes.c_ubyte</td></tr><tr><td>‘h’</td><td>ctypes.c_short</td></tr><tr><td>‘H’</td><td>ctypes.c_ushort</td></tr><tr><td>‘i’</td><td>ctypes.c_int</td></tr><tr><td>‘I’</td><td>ctypes.c_uint</td></tr><tr><td>‘l’</td><td>ctypes.c_long</td></tr><tr><td>‘L’</td><td>ctypes.c_ulong</td></tr><tr><td>‘f’</td><td>ctypes.c_float</td></tr><tr><td>‘d’</td><td>ctypes.c_doubl</td></tr></tbody></table><p>创建后，只要将这些变量传递给子进程即可。</p><h3 id="通过-Manager-创建共享变量"><a href="#通过-Manager-创建共享变量" class="headerlink" title="通过 Manager 创建共享变量"></a>通过 Manager 创建共享变量</h3><p>Manager() 返回的 manager 对象提供一个服务进程，使得其他进程可以通过代理的方式操作 Python 对象。 Manager 支持 list、dict 等多种数据类型。 （<a href="http://www.liujiangblog.com/course/python/82" target="_blank" rel="noopener">多进程multiprocess</a>）</p><p>把之前的共享变量的代码中，共享的变量由 list 改为 Manager 对象创建的 list，可以得到正确结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock, Manager</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(lock, var, index)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        var.append(index)</span><br><span class="line">        print(<span class="string">f"Process <span class="subst">&#123;index&#125;</span> apped <span class="subst">&#123;index&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    var = Manager().list()</span><br><span class="line">    lock = Lock()</span><br><span class="line">    process_list = [Process(target=work, args=(lock, var, i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">        p.join()</span><br><span class="line">    print(var)</span><br></pre></td></tr></table></figure><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>进程间通信，可以起到共享变量的效果，也可以起到锁的效果。</p><p>进程间通信的方式有三种：</p><ul><li>事件（Event）</li><li>队列（Queue）</li><li>管道（Pipe）</li></ul><h2 id="通过事件（Event）通信"><a href="#通过事件（Event）通信" class="headerlink" title="通过事件（Event）通信"></a>通过事件（Event）通信</h2><p>Event 是同步通信的方式，有些类似于条件锁。由于是它是同步的，而且不能传递数据。 因此这里就不仔细研究 Event 的作用。</p><p>这个例子示例了主进程与子进程之间通过 Event 进行通信的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_for_event</span><span class="params">(e)</span>:</span></span><br><span class="line">    print(<span class="string">"wait_for_event: starting"</span>)</span><br><span class="line">    e.wait()</span><br><span class="line">    print(<span class="string">"wairt_for_event: e.is_set()-&gt;"</span> + str(e.is_set()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_for_event_timeout</span><span class="params">(e, t)</span>:</span></span><br><span class="line">    print(<span class="string">"wait_for_event_timeout:starting"</span>)</span><br><span class="line">    e.wait(t)</span><br><span class="line">    print(<span class="string">"wait_for_event_timeout:e.is_set-&gt;"</span> + str(e.is_set()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    e = multiprocessing.Event()</span><br><span class="line">    w1 = multiprocessing.Process(target=wait_for_event, args=(e,))</span><br><span class="line">    w2 = multiprocessing.Process(target=wait_for_event_timeout, args=(e, <span class="number">6</span>))</span><br><span class="line">    w1.start()</span><br><span class="line">    w2.start()</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">"main: event setting"</span>)</span><br><span class="line">    e.set()</span><br><span class="line">    print(<span class="string">"main: event is set"</span>)</span><br></pre></td></tr></table></figure><h2 id="通过队列（Queue）通信"><a href="#通过队列（Queue）通信" class="headerlink" title="通过队列（Queue）通信"></a>通过队列（Queue）通信</h2><p>Queue 是多进程安全的队列，可以使用 Queue 实现多进程之间的数据传递。 Queue 有两个方法：</p><ul><li><code>put()</code>：将数据插入队列中。</li><li><code>get()</code>：从队列读取并且删除一个元素。</li></ul><p>这两个方法都有两个参数：<code>blocked</code>, <code>timeout</code>， 控制队满和队空两种情况：</p><ul><li><code>put</code>：当队满时，如果 <code>blocked=True</code> ，那么会阻塞 <code>timeout</code> 指定的时间，直到队列有空间。如果超时，或 <code>blocked=False</code> ，则抛出 <code>Queue.Full</code> 异常。</li><li><code>get</code>：当队满时，如果 <code>blocked=True</code> ，那么会阻塞 <code>timeout</code> 指定的时间，直到队列有元素。如果超时，或 <code>blocked=False</code> ，则抛出 <code>Queue.Empty</code> 异常。</li></ul><p>调用实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FineTargetTaxiProcess</span><span class="params">(mp.Process)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    处理进程：多进程方式处理文件，结果全部传递给打印进程。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_files, index, queue)</span>:</span></span><br><span class="line">        mp.Process.__init__(self, target=self.pick, args=(queue,))</span><br><span class="line">        self.input_files = input_files</span><br><span class="line">        self.index = index</span><br><span class="line">        self.lock = lock</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> tqdm(self.input_files, ncols=<span class="number">80</span>, position=self.index, desc=<span class="string">f"Process <span class="subst">&#123;self.index&#125;</span>"</span>):</span><br><span class="line">            <span class="keyword">with</span> open(filename, encoding=<span class="string">"GB2312"</span>) <span class="keyword">as</span> in_file:</span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> in_file:</span><br><span class="line">                    cells = row.split(<span class="string">","</span>)</span><br><span class="line">                    <span class="keyword">if</span> int(cells[<span class="number">0</span>]) == <span class="number">11865</span>:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            queue.put(<span class="string">","</span>.join(cells), block=<span class="keyword">False</span>)</span><br><span class="line">                        <span class="keyword">except</span>:</span><br><span class="line">                            print(<span class="string">"Queue full"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrinterProcess</span><span class="params">(mp.Process)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印进程：维持对输出文件的打开状态，打印数据。</span></span><br><span class="line"><span class="string">    可避免频繁打开、关闭结果文件造成的系统开销，</span></span><br><span class="line"><span class="string">    但是引入了消息传递的开销。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, output_file, log, queue)</span>:</span></span><br><span class="line">        mp.Process.__init__(self, target=self.write, args=(queue,))</span><br><span class="line">        self.output_file = output_file</span><br><span class="line">        self.log_file = log</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, queue)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(self.output_file, mode=<span class="string">"w"</span>, newline=<span class="string">"\n"</span>) <span class="keyword">as</span> printer, open(self.log_file, mode=<span class="string">"w"</span>) <span class="keyword">as</span> log:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    row = queue.get(block=<span class="keyword">True</span>, timeout=<span class="number">1</span>)</span><br><span class="line">                    print(row, file=printer)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    print(<span class="string">"Queue empty"</span>, file=log)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = mp.Lock()</span><br><span class="line">    ROOT_DIR = <span class="string">r"/mnt/e/出租车点/201502/RawCSV"</span></span><br><span class="line">    INPUT_FILES = [os.path.join(ROOT_DIR, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(ROOT_DIR)]</span><br><span class="line">    GROUP_LIST = distrib_works(INPUT_FILES, <span class="number">6</span>)</span><br><span class="line">    QUEUE = mp.Queue()</span><br><span class="line">    PROCESS_LIST = [FineTargetTaxiProcess(element, i, QUEUE) <span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(GROUP_LIST)]</span><br><span class="line">    PRINTER_PROCESS = PrinterProcess(<span class="string">"./data/usequeue.txt"</span>, <span class="string">"./data/usequeue.log"</span>, QUEUE)</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> PROCESS_LIST:</span><br><span class="line">        process.daemon = <span class="keyword">True</span></span><br><span class="line">        process.start()</span><br><span class="line">    PRINTER_PROCESS.daemon = <span class="keyword">True</span></span><br><span class="line">    PRINTER_PROCESS.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> PROCESS_LIST:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><h2 id="通过管道（Pipe）通信"><a href="#通过管道（Pipe）通信" class="headerlink" title="通过管道（Pipe）通信"></a>通过管道（Pipe）通信</h2><p>Pipe 是一个可以双向通信的对象，返回 <code>(conn1, conn2)</code>， 代表一个管道的两个端， <code>conn1</code> 只负责接受消息， <code>conn2</code> 只负责发送消息。 如果设置了 <code>duplex=True</code> ，那么这个管道是全双工模式， <code>conn1</code> 和 <code>conn2</code> 均可收发。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FineTargetTaxiProcess</span><span class="params">(mp.Process)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    处理进程：多进程方式处理文件，结果全部传递给打印进程。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_files, index, pipe)</span>:</span></span><br><span class="line">        mp.Process.__init__(self, target=self.pick, args=(pipe,))</span><br><span class="line">        self.input_files = input_files</span><br><span class="line">        self.index = index</span><br><span class="line">        self.lock = lock</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, pipe)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> tqdm(self.input_files, ncols=<span class="number">80</span>, position=self.index, desc=<span class="string">f"Process <span class="subst">&#123;self.index&#125;</span>"</span>):</span><br><span class="line">            <span class="keyword">with</span> open(filename, encoding=<span class="string">"GB2312"</span>) <span class="keyword">as</span> in_file:</span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> in_file:</span><br><span class="line">                    cells = row.split(<span class="string">","</span>)</span><br><span class="line">                    <span class="keyword">if</span> int(cells[<span class="number">0</span>]) == <span class="number">11865</span>:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            pipe.send(<span class="string">","</span>.join(cells))</span><br><span class="line">                        <span class="keyword">except</span> e <span class="keyword">as</span> Exception:</span><br><span class="line">                            print(<span class="string">"Pipe send error"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrinterProcess</span><span class="params">(mp.Process)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    打印进程：维持对输出文件的打开状态，打印数据。</span></span><br><span class="line"><span class="string">    可避免频繁打开、关闭结果文件造成的系统开销，</span></span><br><span class="line"><span class="string">    但是引入了消息传递的开销。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, output_file, log, pipe)</span>:</span></span><br><span class="line">        mp.Process.__init__(self, target=self.write, args=(pipe,))</span><br><span class="line">        self.output_file = output_file</span><br><span class="line">        self.log_file = log</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self, pipe)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(self.output_file, mode=<span class="string">"w"</span>, newline=<span class="string">"\n"</span>) <span class="keyword">as</span> printer, open(self.log_file, mode=<span class="string">"w"</span>) <span class="keyword">as</span> log:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    row = pipe.recv()</span><br><span class="line">                    print(row, file=printer)</span><br><span class="line">                <span class="keyword">except</span> e <span class="keyword">as</span> Exception:</span><br><span class="line">                    print(<span class="string">"Pipe read error"</span>, file=log)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lock = mp.Lock()</span><br><span class="line">    <span class="comment"># ROOT_DIR = "../data/201502/temp"</span></span><br><span class="line">    ROOT_DIR = <span class="string">r"/mnt/e/出租车点/201502/RawCSV"</span></span><br><span class="line">    INPUT_FILES = [os.path.join(ROOT_DIR, f) <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(ROOT_DIR)]</span><br><span class="line">    GROUP_LIST = distrib_works(INPUT_FILES, <span class="number">6</span>)</span><br><span class="line">    (RECEIVER, SENDER) = mp.Pipe()</span><br><span class="line">    PROCESS_LIST = [FineTargetTaxiProcess(element, i, SENDER) <span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(GROUP_LIST)]</span><br><span class="line">    PRINTER_PROCESS = PrinterProcess(<span class="string">"./data/usepipe.txt"</span>, <span class="string">"./data/usepipe.log"</span>, RECEIVER)</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> PROCESS_LIST:</span><br><span class="line">        process.daemon = <span class="keyword">True</span></span><br><span class="line">        process.start()</span><br><span class="line">    PRINTER_PROCESS.daemon = <span class="keyword">True</span></span><br><span class="line">    PRINTER_PROCESS.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> PROCESS_LIST:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="tqdm-多进度条"><a href="#tqdm-多进度条" class="headerlink" title="tqdm 多进度条"></a>tqdm 多进度条</h2><p>是一个快速，可扩展的 Python 进度条，可以在 Python 长循环中添加一个进度提示信息， 用户只需要封装任意的迭代器 <code>tqdm(iterator)</code> 。</p><p>这里有一些参数：</p><ul><li><code>ncols</code>：整个进度条（包括条以及其他文字）的宽度。最好设置一个小于控制台总宽的值。</li><li><code>mininterval</code>：进度条更新的最小间隔。默认为 0.1。</li><li><code>position</code>：进度条的位置，从0开始。对不同的 tqdm 对象设置不同的 position，可以在控制台的不同位置显示出来，适用于多进程与多线程。</li></ul><blockquote><p>由于 Windows 上多进程时 tqdm 无法获取默认的锁，所以会出现进度条错乱。在 Linux 上是没有问题的。</p></blockquote><h2 id="Windows-上-Lock-的问题"><a href="#Windows-上-Lock-的问题" class="headerlink" title="Windows 上 Lock 的问题"></a>Windows 上 Lock 的问题</h2><p>其实每次传入子进程函数内部的 <code>Lock</code>，在各个进程中的 <code>id</code> 都不一样。在 Linux 下没有这个问题。 这往往会导致一些程序在 Windows 上不正确。 因此，在 Windows 上最好少用 <code>Lock</code>，多采用消息传递或共享变量的方式设计程序。</p><div class="post-announce">感谢您的阅读，本文由 <a href="http://hpdell.github.io">HPDell 的个人博客</a> 版权所有。如若转载，请注明出处：HPDell 的个人博客（<a href="http://hpdell.github.io/编程/py-multiprocess/">http://hpdell.github.io/编程/py-multiprocess/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/编程/wpf-plug/" title="WPF 使用消息插销（Plug）机制在多个组件之间传递消息"><i class="iconfont icon-prev"></i>WPF 使用消息插销（Plug）机制在多个组件之间传递消息</a></div><div class="post__prev post__prev--right"><a href="/编程/usually-use-code/" title="常用代码">常用代码<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">HPDell 的博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/随笔/">随笔</a><span class="block-list-count">9</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/编程/">编程</a><span class="block-list-count">24</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/理论/">理论</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/其他/">其他</a><span class="block-list-count">5</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/理论/genshin-impact-critical/" title="原神中为什么暴击暴伤比为1:2最好？"><div class="item__cover"><img src="/assets/cover/genshin-impact-critical.jpg" alt="原神中为什么暴击暴伤比为1:2最好？"></div><div class="item__info"><h3 class="item__title">原神中为什么暴击暴伤比为1:2最好？</h3><span class="item__text">2022-03-25</span></div></a></li><li class="latest-post-item"><a href="/编程/dynamic-blog-v2/" title="自己动手写动态博客（二）"><div class="item__cover"><img src="/assets/cover/dynamic-blog-v2.png" alt="自己动手写动态博客（二）"></div><div class="item__info"><h3 class="item__title">自己动手写动态博客（二）</h3><span class="item__text">2022-03-20</span></div></a></li><li class="latest-post-item"><a href="/编程/windows-cmd-mklink/" title="Windows 创建符号链接的命令 mklink"><div class="item__cover"><img src="/assets/img/header_cover.jpg" alt="Windows 创建符号链接的命令 mklink"></div><div class="item__info"><h3 class="item__title">Windows 创建符号链接的命令 mklink</h3><span class="item__text">2022-01-19</span></div></a></li><li class="latest-post-item"><a href="/随笔/wind-from-luoyang/" title="《风起洛阳》观后感"><div class="item__cover"><img src="/assets/cover/wind-from-luoyang.jpg" alt="《风起洛阳》观后感"></div><div class="item__info"><h3 class="item__title">《风起洛阳》观后感</h3><span class="item__text">2021-12-31</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Apache-POI/">Apache POI</a></li><li class="tag-item"><a class="tag-link" href="/tags/Bootstrap/">Bootstrap</a></li><li class="tag-item"><a class="tag-link" href="/tags/C/">C#</a></li><li class="tag-item"><a class="tag-link" href="/tags/CUDA/">CUDA</a></li><li class="tag-item"><a class="tag-link" href="/tags/Django/">Django</a></li><li class="tag-item"><a class="tag-link" href="/tags/GitLab-Runner/">GitLab Runner</a></li><li class="tag-item"><a class="tag-link" href="/tags/LaTeX/">LaTeX</a></li><li class="tag-item"><a class="tag-link" href="/tags/Linux/">Linux</a></li><li class="tag-item"><a class="tag-link" href="/tags/Node-js/">Node.js</a></li><li class="tag-item"><a class="tag-link" href="/tags/Python/">Python</a></li><li class="tag-item"><a class="tag-link" href="/tags/QGIS/">QGIS</a></li><li class="tag-item"><a class="tag-link" href="/tags/Qt/">Qt</a></li><li class="tag-item"><a class="tag-link" href="/tags/R/">R</a></li><li class="tag-item"><a class="tag-link" href="/tags/TypeScript/">TypeScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/Vue/">Vue</a></li><li class="tag-item"><a class="tag-link" href="/tags/WPF/">WPF</a></li><li class="tag-item"><a class="tag-link" href="/tags/Windows/">Windows</a></li><li class="tag-item"><a class="tag-link" href="/tags/XAML/">XAML</a></li><li class="tag-item"><a class="tag-link" href="/tags/jQuery-Mobile/">jQuery Mobile</a></li><li class="tag-item"><a class="tag-link" href="/tags/travis/">travis</a></li><li class="tag-item"><a class="tag-link" href="/tags/博客相关/">博客相关</a></li><li class="tag-item"><a class="tag-link" href="/tags/原神/">原神</a></li><li class="tag-item"><a class="tag-link" href="/tags/哈利波特/">哈利波特</a></li><li class="tag-item"><a class="tag-link" href="/tags/影评/">影评</a></li><li class="tag-item"><a class="tag-link" href="/tags/测试/">测试</a></li><li class="tag-item"><a class="tag-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-item"><a class="tag-link" href="/tags/电影/">电影</a></li><li class="tag-item"><a class="tag-link" href="/tags/统计学/">统计学</a></li><li class="tag-item"><a class="tag-link" href="/tags/网页开发/">网页开发</a></li><li class="tag-item"><a class="tag-link" href="/tags/课程/">课程</a></li><li class="tag-item"><a class="tag-link" href="/tags/路网速度/">路网速度</a></li><li class="tag-item"><a class="tag-link" href="/tags/随笔/">随笔</a></li></ul></div><div class="sidebar__block__sticky"><h3 class="block__title">目录</h3><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Python-多进程对效率的提升"><span class="toc-text">Python 多进程对效率的提升</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Python-开启多进程"><span class="toc-text">Python 开启多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建-Process-对象"><span class="toc-text">创建 Process 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造参数"><span class="toc-text">构造参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用示例"><span class="toc-text">调用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将进程定义为类"><span class="toc-text">将进程定义为类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程池（Pool）"><span class="toc-text">进程池（Pool）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程池构造"><span class="toc-text">进程池构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程池方法"><span class="toc-text">进程池方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程池调用示例"><span class="toc-text">进程池调用示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多进程共享资源"><span class="toc-text">多进程共享资源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#锁"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#互斥锁（Lock）"><span class="toc-text">互斥锁（Lock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可重入锁（RLock）"><span class="toc-text">可重入锁（RLock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件锁（Condition"><span class="toc-text">条件锁（Condition)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号量（Semaphore）"><span class="toc-text">信号量（Semaphore）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享变量"><span class="toc-text">共享变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#multiprocess-包内置类型"><span class="toc-text">multiprocess 包内置类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过-Manager-创建共享变量"><span class="toc-text">通过 Manager 创建共享变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程间通信"><span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通过事件（Event）通信"><span class="toc-text">通过事件（Event）通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过队列（Queue）通信"><span class="toc-text">通过队列（Queue）通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过管道（Pipe）通信"><span class="toc-text">通过管道（Pipe）通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tqdm-多进度条"><span class="toc-text">tqdm 多进度条</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-上-Lock-的问题"><span class="toc-text">Windows 上 Lock 的问题</span></a></li></ol></li></ol></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">HPDell的博客，基于Hexo。分享生活，分享技术，分享观点，为自己留下感动。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Wuhan University, Luoyu Road, Wuhan, Hubei, China.</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>huyg0180110559@outlook.com</span></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://blog.huyg.site:8443/" title="我的动态博客" target="_blank">我的动态博客</a></li><li class="list-item"><a href="https://hkvision.cn/" title="HaoKunT的博客" target="_blank">HaoKunT的博客</a></li><li class="list-item"><a href="https://home.cs-tao.cc/" title="这是一个不能停留太久的世界" target="_blank">CS-Tao</a></li><li class="list-item"><a href="http://gwmodel.whu.edu.cn/#/" title="地理加权建模实验室" target="_blank">GWmodel-Lab</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/HPDell" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:huyg0180110559@outlook.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li><li class="social-network__item"><a href="https://www.zhihu.com/people/hu-yi-gong-63/activities" target="_blank" title="知乎"><i class="iconfont icon-zhihu"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["Python"],gitalk=new Gitalk({clientID:"47d3a0c03f3c07172ecc",clientSecret:"8e0da02c5e757c77b93627a7e380e43a248d001c",repo:"HPDell.github.io",owner:"HPDell",admin:["HPDell"],labels:tags,id:new Date(1531162387e3).getTime()>new Date("2018-02-15").getTime()?md5(encodeURI(decodeURI(location.href))):location.href});gitalk.render("comment-container")</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>!function(n){var o=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(t,e){var n=new Image,o=t.getAttribute("data-original");n.onload=function(){t.src=o,e&&e()},n.src=o}function c(){for(var t=0;t<o.length;t++)0<=(e=o[t].getBoundingClientRect()).top&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&i(o[t],function(){o.splice(t,t)});var e;console.log("trigger")}c(),n.addEventListener("scroll",function(){var t,e;t=c,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script></body></html>