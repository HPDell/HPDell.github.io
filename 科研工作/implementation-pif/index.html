<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>Path-Inference-Filter(PIF) 算法调用的实现 | 我们在小孩和大人的转角盖一座城堡</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="hpdell"><meta name="designer" content="minfive"><meta name="keywords" content="undefined"><meta name="description" content="HPDell 的博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://hpdell.github.io/科研工作/implementation-pif/index.html"><link rel="icon" type="image/png" href="/assets/img/avatar.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="HPDell 的个人博客"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart=""><div id="page-loading" class="page page-loading" style="background-image:url(undefined)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="HPDell 的个人博客" alt="HPDell 的个人博客"><img src="/assets/img/avatar.jpg" alt="HPDell 的个人博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/assets/img/header_cover.jpg" alt="Path-Inference-Filter(PIF) 算法调用的实现"></div><header class="post__info"><h1 class="post__title">Path-Inference-Filter(PIF) 算法调用的实现</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">HPDell</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-01-04</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/路网速度/">路网速度</a></li></ul></div></div></header><div class="post__content"><p>Path Inference Filter(PIF, 道路推断滤波)算法是一种基于概率的路网匹配算法。其核心代码已经开源在 <a href="https://github.com/tjhunter/Path-Inference-Filter" target="_blank" rel="noopener">GitHub</a> 上，作者也提供了一个<code>example.py</code>文件，来介绍如何使用。我由于需要将此算法真实用于路网匹配中，因此需要根据实际路网对此算法进行调用。之前使用 ArcPy 写了一个，但是运行速度非常慢，而且跑着跑着电脑就自动关机了。所以现在就用 PostGIS 和 pgRouting 重新实现一个版本。 <a id="more"></a></p><h1 id="PIF-的数学原理"><a href="#PIF-的数学原理" class="headerlink" title="PIF 的数学原理"></a>PIF 的数学原理</h1><p>此处详细情况请参考论文 <em><a href="http://bayen.eecs.berkeley.edu/sites/default/files/journals/The_Path_Inference_Filter.pdf" target="_blank" rel="noopener">The Path Inference Filter: Model-Based Low-Latency Map Matching of Probe Vehicle Data</a></em> 。后面我会补充一个自己整理的简略版原理。</p><h1 id="PIF-的接口调用"><a href="#PIF-的接口调用" class="headerlink" title="PIF 的接口调用"></a>PIF 的接口调用</h1><p>PIF 核心库提供了一些类供我们使用。比如：</p><ul><li><code>State</code>和<code>StateCollection</code>：描述状态值的类及状态值的集合。</li><li><code>LatLng</code>：表示经纬度的对象。</li><li><code>PathBuilder</code>：路径建立类。用于生成状态值之间的可达路径。</li><li><code>LearningTrajectory</code>：用于获取轨迹的描述。</li><li><code>TrajectoryViterbi1</code>：用于计算概率最大的轨迹。</li><li><code>TrajectorySmoother1</code>：用于滤波。</li></ul><p><code>State</code>、<code>StateCollection</code>、<code>LatLng</code>三个类可以直接使用。对于我们拿到的 GPS 数据来说，一般都会有一些附加的属性值，例如速度、方向、车辆状态等。可以创建自己的继承自<code>LatLng</code>和<code>State</code>的子类，添加这些属性。</p><p>我们可以将一些常用的函数，封装到类<code>WuhanRoadFilter</code>中，例如：计算距离的函数<code>distance</code>、计算状态值特征向量和路径特征向量的函数等。该类的形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WuhanRoadFilter</span>:</span></span><br><span class="line">    <span class="string">''' 路径滤波类</span></span><br><span class="line"><span class="string">    对武汉市道路网络数据和Path-Inference-Path的封装。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    属性：</span></span><br><span class="line"><span class="string">    - `network`: 网络数据集</span></span><br><span class="line"><span class="string">    - `line_features`: 要素数据集</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, conn)</span>:</span></span><br><span class="line">        <span class="string">''' 构造函数</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        self.conn = conn <span class="comment"># type: psycopg2.exetensions.connection</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(self, coord1: LatLng, coord2: LatLng)</span> -&gt; float:</span></span><br><span class="line">        <span class="string">''' 求两地理坐标之间的距离</span></span><br><span class="line"><span class="string">        - `coord1`: 经纬度坐标值</span></span><br><span class="line"><span class="string">        - `coord2`: 经纬度坐标值</span></span><br><span class="line"><span class="string">        - `spatial_ref`: 空间参考。默认为GCS_WGS_1984</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">point_feature_vector</span><span class="params">(self, state_collection: StateCollection)</span>:</span></span><br><span class="line">        <span class="string">""" 点的特征向量</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">path_feature_vector</span><span class="params">(self, select_path: Tuple[State, List, State, float])</span>:</span></span><br><span class="line">        <span class="string">""" 路径的特征向量</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_posibility_states</span><span class="params">(self, point: TaxiPoint, distance: float)</span>:</span></span><br><span class="line">        <span class="string">''' 获取最可能的状态</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">        - `link_id`: 路段ID</span></span><br><span class="line"><span class="string">        - `point`: 要寻找的点。格式为(lon, lat)的二元组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        返回值: StateCollection</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_observations</span><span class="params">(self, file_path: str, filting=<span class="number">0</span>)</span> -&gt; List[List[StateCollection]]:</span></span><br><span class="line">        <span class="string">''' 创建观测值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">        - `file_path`: 观测值XML文件路径</span></span><br><span class="line"><span class="string">        - `filting`: 观测值序列最少的点数</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在调用过程中，可以创建<code>PathBuilder</code>的子类，来实现自己的路径搜索。子类中只需要实现方法<code>getPaths()</code>。此方法用于在方法<code>getPathsBetweenCollections()</code>中调用以获取路径。必须实现，否则会抛出<code>NotImplementedError</code>的错误。我们创建类<code>WuhanRoadBuilder</code>，在该类中实现<code>getPaths()</code>方法。该类的形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WuhanRoadBuilder</span><span class="params">(PathBuilder)</span>:</span></span><br><span class="line">    <span class="string">''' 武汉市路网的路径工厂</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    路径工厂会生成两个状态集合之间的所有路径</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, conn)</span>:</span></span><br><span class="line">        <span class="comment"># PathBuilder.__init__()</span></span><br><span class="line">        self.conn = conn <span class="comment"># type: psycopg2.extensions.connection</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPaths</span><span class="params">(self, s1: State, s2: State)</span>:</span></span><br><span class="line">        <span class="string">''' 获取两个状态之间的路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        利用ArcPy获取路网上两点之间的最短路径</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这些函数和 PIF 框架的调用过程可参考 PIF 库中的<code>example.py</code>文件。</p><h1 id="利用-pgRouting-实现调用-PIF-算法"><a href="#利用-pgRouting-实现调用-PIF-算法" class="headerlink" title="利用 pgRouting 实现调用 PIF 算法"></a>利用 pgRouting 实现调用 PIF 算法</h1><p>借助 PostGIS 和 pgRouting 可以实现路径搜索功能，而使用 PostGIS 提供的大量的关于几何和地理数据的函数，可以方便实现对 PIF 算法的调用。但是这里需要编写的数据库函数，需要一定的数据库编程的能力。为了能够和 Python 编写的 PIF 核心代码结合起来，需要使用 Python 调用 PostgreSQL 函数，并将结果转化为 Geometry 及其子类型的对象。</p><h2 id="使用到的-Python-包"><a href="#使用到的-Python-包" class="headerlink" title="使用到的 Python 包"></a>使用到的 Python 包</h2><p>使用下面两个包即可：</p><ol><li><a href="http://initd.org/psycopg/docs/index.html" target="_blank" rel="noopener">psycopg2</a>：封装了对 PostgreSQL 数据库的操作。</li><li><a href="https://github.com/yohanboniface/python-postgis" target="_blank" rel="noopener">postgis</a>：封装了 PostGIS 空间类型。</li></ol><h2 id="准备路网数据"><a href="#准备路网数据" class="headerlink" title="准备路网数据"></a>准备路网数据</h2><p>假设我们要导入的路网数据名字叫<code>road</code>。一般情况下，我们拿到的数据，坐标系为 WGS84 或常用的投影坐标系（如CGCS2000）。在 WGS84 坐标系下的数据，以<code>Geography</code>类型存储在数据库中，在投影坐标系下的数据，以<code>Geometry</code>类型存储在数据库中。在 <a href="http://postgis.net/docs/manual-2.4/using_postgis_dbmanagement.html#PostGIS_Geography" target="_blank" rel="noopener">PostGIS</a> 的文档中，建议使用<code>Geometry</code>类型存储数据，以减小计算量。</p><blockquote><p>The geography type allows you to store data in longitude/latitude coordinates, but at a cost: there are fewer functions defined on GEOGRAPHY than there are on GEOMETRY; those functions that are defined take more CPU time to execute.</p><p><em>Geography 类型允许你以经纬度坐标的方式存储数据，但是代价是：Geography 类型比 Geometry 类型的函数少；Geography 类型的函数执行起来消耗更多的 CPU 时间。</em></p><p>The type you choose should be conditioned on the expected working area of the application you are building. Will your data span the globe or a large continental area, or is it local to a state, county or municipality?</p><ul><li>If your data is contained in a small area, you might find that choosing an appropriate projection and using GEOMETRY is the best solution, in terms of performance and functionality available.</li><li>If your data is global or covers a continental region, you may find that GEOGRAPHY allows you to build a system without having to worry about projection details. You store your data in longitude/latitude, and use the functions that have been defined on GEOGRAPHY.</li><li>If you don’t understand projections, and you don’t want to learn about them, and you’re prepared to accept the limitations in functionality available in GEOGRAPHY, then it might be easier for you to use GEOGRAPHY than GEOMETRY. Simply load your data up as longitude/latitude and go from there.</li></ul></blockquote><p>因此，我们采用投影坐标系的路网数据。</p><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p>导入时数据的方法非常简单，使用 PostGIS Shapefiel Import/Export Manager(PostGIS 2.0 Shapefile and DBF Loader Exporter) 工具导入即可。</p><img src="/科研工作/implementation-pif/PostGIS-Shp-Tool.png"><p>在这个工具上设置数据库的连接，选择要导入的 shp 文件。选定 shp 文件后，最好点击 Options 按钮打开选项，选中最后一个复选框。</p><img src="/科研工作/implementation-pif/shp-options.png"><p>确定后，点击 Improt 按钮开始导入。等待其完成即可。</p><p>需要注意的是，shp 文件的名字，会作为最终导入到数据库中表的名字。</p><h3 id="拓扑关系建立"><a href="#拓扑关系建立" class="headerlink" title="拓扑关系建立"></a>拓扑关系建立</h3><p>我们导入的数据集，在网络结构中数据“边”类型，pgRouting 称之为 <em>edge</em>。pgRouting 需要知道每个 edge 的起点和终点的序号是什么，需要知道路径的长度是多少。需要给<code>road</code>数据集添加三个字段：<code>source</code>、<code>target</code>和<code>length</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> road <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="keyword">source</span> <span class="built_in">integer</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> road <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> target <span class="built_in">integer</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> road <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="keyword">length</span> <span class="keyword">double</span> <span class="keyword">precision</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> road <span class="keyword">set</span> <span class="keyword">length</span> = ST_Length(geom); <span class="comment">-- 为路段长度赋值</span></span><br></pre></td></tr></table></figure><p>当然这两个字段的名字可以自己取。路径长度字段如果已经有了，也可以不用重新建立。</p><p>然后是拓扑关系的建立。使用 pgRouting 提供的函数 <a href="http://docs.pgrouting.org/2.4/en/pgr_createTopology.html#pgr-createtopology" target="_blank" rel="noopener"><code>pgr_createTopology()</code></a> 来创建拓扑，该函数有以下参数：</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td><code>edge_table</code></td><td>路网表名（也可以包含数据库名）。文本类型。</td></tr><tr><td><code>tolerance</code></td><td>路段不连续误差。8字节浮点数类型。</td></tr><tr><td><code>the_geom</code></td><td>路网表中 Geometry 列的名称（默认是”the_geom”）。文本类型。</td></tr><tr><td><code>id</code></td><td>路网表中主键列的名称（默认是”id”）。文本类型。</td></tr><tr><td><code>source</code></td><td>路网表中 source 列的名称（默认是”source”）。文本类型。</td></tr><tr><td><code>target</code></td><td>路网表中 target 列的名称（默认是”target”）。文本类型。</td></tr><tr><td><code>rows_where</code></td><td>用于选择一个子集或多行的 SELECT 条件。默认值是选择所有 source 和 target 为空的行。文本类型。</td></tr><tr><td><code>clean</code></td><td>是否清除之前的拓扑关系（默认是 false ）。布尔型。</td></tr></tbody></table><p>具体调用实例为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pgr_createTopology(<span class="string">'public.road'</span>, <span class="number">0.001</span>, <span class="string">'geom'</span>, <span class="string">'gid'</span>);</span><br></pre></td></tr></table></figure><p>路网数据准备完成。</p><h2 id="计算两点间距离"><a href="#计算两点间距离" class="headerlink" title="计算两点间距离"></a>计算两点间距离</h2><p>这里只需要使用到 PostGIS 提供的函数<code>ST_Distance()</code>，函数的用法非常简单，可参考<a href="http://postgis.net/docs/manual-2.4/ST_Distance.html" target="_blank" rel="noopener">官网文档</a>。为了方便调用，我们设计一个数据库函数<code>PIF_GetDistance()</code>，使其可以直接输入两个坐标值，进行距离计算。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> <span class="string">"public"</span>.<span class="string">"PIF_GetDistance"</span>(<span class="string">"x1"</span> float8, <span class="string">"y1"</span> float8, <span class="string">"x2"</span> float8, <span class="string">"y2"</span> float8)</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="string">"pg_catalog"</span>.<span class="string">"float8"</span> <span class="keyword">AS</span> $<span class="keyword">BODY</span>$</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">	point1 Geometry := ST_Transform(ST_SetSrid(ST_Point(x1, y1), <span class="number">4326</span>), <span class="number">3857</span>);</span><br><span class="line">	point2 Geometry := ST_Transform(ST_SetSrid(ST_Point(x2, y2), 4326), 3857);</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="comment">-- Routine body goes here...</span></span><br><span class="line">	<span class="keyword">RETURN</span> ST_Distance(point1, point2);</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$<span class="keyword">BODY</span>$</span><br><span class="line">  <span class="keyword">LANGUAGE</span> plpgsql VOLATILE</span><br><span class="line">  <span class="keyword">COST</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><p>Python 中调用此函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance</span><span class="params">(self, coord1: LatLng, coord2: LatLng)</span> -&gt; float:</span></span><br><span class="line">    <span class="string">''' 求两地理坐标之间的距离</span></span><br><span class="line"><span class="string">    - `coord1`: 经纬度坐标值</span></span><br><span class="line"><span class="string">    - `coord2`: 经纬度坐标值</span></span><br><span class="line"><span class="string">    - `spatial_ref`: 空间参考。默认为GCS_WGS_1984</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    cur = self.conn.cursor()</span><br><span class="line">    cur.execute(<span class="string">'SELECT "PIF_GetDistance"(%s, %s, %s, %s)'</span>,</span><br><span class="line">                (coord1.lng, coord1.lat, coord2.lng, coord2.lat))</span><br><span class="line">    <span class="keyword">return</span> cur.fetchone()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="获取每个-GPS-点对应的状态值"><a href="#获取每个-GPS-点对应的状态值" class="headerlink" title="获取每个 GPS 点对应的状态值"></a>获取每个 GPS 点对应的状态值</h2><p>状态值的获取是在一个路段上计算一个联合分布 $$ π(x|g) = ω(g|x)Ω(x) $$ 其中 $ x $ 是状态值，$ g $ 是 GPS 观测值。但是由于分布 $ ω(g|x) $ 服从正态分布，$ Ω(x) $ 在没有先验知识的情况下，服从均匀分布，因此直接取路段上距离 GPS 观测值最近的点即可。</p><h3 id="需要使用到的-PostGIS-函数"><a href="#需要使用到的-PostGIS-函数" class="headerlink" title="需要使用到的 PostGIS 函数"></a>需要使用到的 PostGIS 函数</h3><p>编写这个数据库函数，需要用到 PostGIS 提供的一些函数，如下（参考 <a href="http://postgis.net/docs/manual-2.4/PostGIS_Special_Functions_Index.html#PostGIS_TypeFunctionMatrix" target="_blank" rel="noopener">PostGIS 文档</a>）：</p><table><thead><tr><th>函数</th><th>用途</th></tr></thead><tbody><tr><td><code>ST_Point(float, float)</code></td><td>构造 Point 对象的函数。</td></tr><tr><td><code>ST_SetSRID(geometry, integer)</code></td><td>设置对象的 SRID（即空间参考）。</td></tr><tr><td><code>ST_Transform(geometry, integer)</code></td><td>将 Geometry 对象进行投影转换。</td></tr><tr><td><code>ST_StartPoint(geometry)</code></td><td>LineString Geometry 对象的第一个点。</td></tr><tr><td><code>ST_EndPoint(geometry)</code></td><td>LineString Geometry 对象的最后一个点。</td></tr><tr><td><code>ST_ClosestPoint(geometry, geometry)</code></td><td>返回第一个 Geometry 对象上距离第二个 Geometry 对象最近的点。</td></tr><tr><td><code>ST_LineLocatePoint(geometry a_linestring, geometry a_point)</code></td><td>返回<code>a_line</code>上距离<code>a_point</code>最近的点在<code>a_line</code>上的百分比。</td></tr></tbody></table><h3 id="编写-PostgreSQL-函数"><a href="#编写-PostgreSQL-函数" class="headerlink" title="编写 PostgreSQL 函数"></a>编写 PostgreSQL 函数</h3><p>函数实现的思路是：首先按照范围筛选处距离指定 GPS 观测值一定距离（例如 100 m）内的路段，然后在这些路段上计算每个最近点。</p><p>数据库函数<code>PIF_GetStatesAtPosition()</code>的定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> public.pif_GetStatesAtPosition(</span><br><span class="line">    lon <span class="built_in">float</span>,</span><br><span class="line">    lat <span class="built_in">float</span>,</span><br><span class="line">    distance <span class="built_in">float</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="keyword">TABLE</span>(StartPoint geometry, EndPoint geometry, States geometry, <span class="keyword">Locate</span> float8, shape_leng <span class="built_in">numeric</span>) <span class="keyword">AS</span> $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">    point_g geometry := ST_Transform(ST_SetSRID(ST_Point(lon, lat), <span class="number">4326</span>), <span class="number">3857</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">RETURN</span> <span class="keyword">QUERY</span> <span class="keyword">SELECT</span> ST_Transform(ST_SetSrid(ST_StartPoint(near_lines.geom), <span class="number">3857</span>), <span class="number">4326</span>) <span class="keyword">AS</span> StartPoint, </span><br><span class="line">                        ST_Transform(ST_SetSrid(ST_EndPoint(near_lines.geom), <span class="number">3857</span>), <span class="number">4326</span>) <span class="keyword">AS</span> EndPoint,</span><br><span class="line">                        ST_Transform(ST_ClosestPoint(ST_SetSRID(near_lines.geom, <span class="number">3857</span>), point_g), <span class="number">4326</span>) <span class="keyword">AS</span> States,</span><br><span class="line">                        ST_LineLocatePoint(ST_SetSRID(near_lines.geom, <span class="number">3857</span>), point_g) <span class="keyword">AS</span> <span class="keyword">Locate</span>,</span><br><span class="line">                        near_lines.shape_leng</span><br><span class="line">                 <span class="keyword">FROM</span> (</span><br><span class="line">                     <span class="keyword">SELECT</span> road.geom, road.shape_leng</span><br><span class="line">                     <span class="keyword">FROM</span> public.road</span><br><span class="line">                     <span class="keyword">WHERE</span> geom &lt;-&gt; point_g &lt; distance</span><br><span class="line">                 ) <span class="keyword">AS</span> near_lines;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$$ LANGUAGE 'plpgsql';</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> public.pif_GetStatesAtPosition(<span class="built_in">float</span>, <span class="built_in">float</span>, <span class="built_in">float</span>)</span><br><span class="line">    OWNER <span class="keyword">TO</span> postgres;</span><br></pre></td></tr></table></figure><blockquote><p>为了避免投影误差，可以将所有结果中的坐标直接以 EPSJ:3857 坐标返回，下次调用时直接用这个坐标系的坐标。这样做同时也可以减少计算量。</p></blockquote><h3 id="Python-函数的编写"><a href="#Python-函数的编写" class="headerlink" title="Python 函数的编写"></a>Python 函数的编写</h3><p>使用 Python 调用这个函数时，直接使用 psycopg2 包查询该函数即可。对于返回结果进行处理，分别创建<code>State</code>对象，最后添加到<code>StateCollection</code>对象中，并返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_posibility_states</span><span class="params">(self, point: TaxiPoint, distance: float)</span>:</span></span><br><span class="line">    <span class="string">''' 获取最可能的状态</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    - `link_id`: 路段ID</span></span><br><span class="line"><span class="string">    - `point`: 要寻找的点。格式为(lon, lat)的二元组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值: StateCollection</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    self.cur.execute(<span class="string">"SELECT startpoint, endpoint, states, locate, shape_leng "</span> +</span><br><span class="line">                     <span class="string">"FROM public.pif_getstatesatposition(%s, %s, %s)"</span>,</span><br><span class="line">                     (point.lng, point.lat, distance))</span><br><span class="line">    states = [] <span class="comment"># type: List[State]</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> self.cur:</span><br><span class="line">        start_point = row[<span class="number">0</span>] <span class="comment"># type: postgis.Point</span></span><br><span class="line">        end_point = row[<span class="number">1</span>] <span class="comment"># type: postgis.Point</span></span><br><span class="line">        closest_point = row[<span class="number">2</span>] <span class="comment"># type: postgis.Point</span></span><br><span class="line">        locate = row[<span class="number">3</span>] <span class="comment"># type: float</span></span><br><span class="line">        shape_leng = row[<span class="number">4</span>] <span class="comment"># type: float</span></span><br><span class="line">        link_id = ((start_point.x, start_point.y), (end_point.x, end_point.y))</span><br><span class="line">        cur_state = State(link_id, locate * float(shape_leng), point)</span><br><span class="line">        states.append(cur_state)</span><br><span class="line">    <span class="keyword">return</span> StateCollection(<span class="keyword">None</span>, states, LatLng(closest_point.y, closest_point.x), <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><blockquote><p>这种查询的方法同样适合于其他支持空间数据的数据库，以及其他类型的语言，例如 C# 和 Java 语言，数据库也可以换成 SQL Server 等其他数据库。问题在于，几乎运行前期绝大部分计算任务都在数据库中完成，数据库计算的压力会比较大，选择一个合适的数据库非常重要。</p></blockquote><h2 id="获取状态值间的最短路径"><a href="#获取状态值间的最短路径" class="headerlink" title="获取状态值间的最短路径"></a>获取状态值间的最短路径</h2><p>根据 PIF 算法的原理，将 GPS 点映射至 $ I^t $ 个元素的候选状态集合 $ \mathbf{x}^t = {x_1^t, x_2^t, ⋯, x_{I^t}^t} $ ，再映射至 $ J^t $ 个元素的路经集合。即对于 $ ∀x_i^t ∈ x^t, \mathbf{x}_i^{t+1} \in \mathbf{x}^{t+1} $，都构造一条路径。路径集记为 $ \mathbf{p}^t $，轨迹为：$$ τ = x_1p_1x_2⋯p_{t-1}x_t $$ PIF 会根据车辆轨迹计算概率，最终取概率最高的一条轨迹作为出租车 GPS 序列再地图上匹配得到的轨迹。</p><h3 id="数据库函数的编写"><a href="#数据库函数的编写" class="headerlink" title="数据库函数的编写"></a>数据库函数的编写</h3><p>PostgreSQL 数据库的插件 pgRouting 提供了路径规划的能力。在建立拓扑关系后，可以使用路径规划系列函数求解最短路径。</p><ul><li><code>pgr_dijkstra()</code>：使用 Dijkstra 算法求解的最短路径。除此之外，还有求解代价的 Dijkstra 函数。</li><li><code>pgr_aStar()</code>：使用 A* 算法求解最短路径。该系列函数即将不受官方支持。</li></ul><p>以<code>pgr_dijkstra()</code>为例，它的参数有：</p><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>sql</code></td><td>文本</td><td>一个 SQL 查询。</td></tr><tr><td><code>source</code></td><td><code>int4</code></td><td>起点的 ID。</td></tr><tr><td><code>target</code></td><td><code>int4</code></td><td>终点的 ID。</td></tr><tr><td><code>directed</code></td><td><code>boolean</code></td><td>如果地图是有向的，那么为<code>ture</code>。</td></tr><tr><td><code>has_rcost</code></td><td><code>boolean</code></td><td>如果为<code>true</code>，SQL 查询的<code>reverse_cost</code>会被用来计算代价值。</td></tr></tbody></table><p>其中 SQL 查询形如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">source</span>, target, <span class="keyword">cost</span> [,reverse_cost] <span class="keyword">FROM</span> edge_table</span><br></pre></td></tr></table></figure><p>返回列有：</p><table><thead><tr><th>列名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>id</code></td><td><code>int4</code></td><td>边的 ID。</td></tr><tr><td><code>source</code></td><td><code>int4</code></td><td>起点的 ID。</td></tr><tr><td><code>target</code></td><td><code>int4</code></td><td>终点的 ID。</td></tr><tr><td><code>cost</code></td><td><code>float</code></td><td>边的代价值。为负则不考虑此边</td></tr><tr><td><code>reverse_cost</code></td><td>可选</td><td>边的往返代价值。只在<code>directed</code>和<code>has_rcost</code>参数为<code>true</code>时使用。</td></tr></tbody></table><p>但是 pgRouting 提供的函数，只支持从路网数据的一个节点到另一个节点，也就是不支持任意两点间的最短路径。我们需要自己撰写函数来实现这一点。对于两个点 $ p_1,p_2 $，求解其间最短路径 $ p_1p_2$ 实现的思路如下：</p><ol><li>找到 $ p_1,p_2 $ 最近的线段 $ l_1, l_2$</li><li>找到 $ l_1 $ 的终点 $p_t$（即<code>target</code>值），和 $ l_2 $ 的起点 $p_s$（即<code>source</code>值）。</li><li>求解从<code>target</code>到<code>source</code>的最短路径 $ p $。</li><li>将 $ p $ 补上或删除 $ p_1p_t $ 和 $ p_sp_2 $ 两段。</li></ol><p>由于在 PIF 中， 要求解路径的点是两个状态值，都在路网上，因此，在搜索最近路段时，搜索范围可放小一点，如 1 m。</p><p>根据<a href="http://blog.csdn.net/longshengguoji/article/details/46793111" target="_blank" rel="noopener">博客</a>，具体函数实现如下（做了一些修改）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> <span class="string">"public"</span>.<span class="string">"pif_getpathbetweenpoints"</span>(<span class="string">"startx"</span> float8, <span class="string">"starty"</span> float8, <span class="string">"endx"</span> float8, <span class="string">"endy"</span> float8)</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span>(<span class="string">"shortest_path"</span> <span class="string">"public"</span>.<span class="string">"geometry"</span>, <span class="string">"path_cost"</span> float8) <span class="keyword">AS</span> $<span class="keyword">BODY</span>$</span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">	tbl <span class="built_in">VARCHAR</span> := <span class="string">'road'</span>;</span><br><span class="line">	v_point1 geometry := st_transform(st_setsrid(ST_Point(startx, starty), 4326), 3857);</span><br><span class="line">	v_point2 geometry := st_transform(st_setsrid(ST_Point(endx, endy), 4326), 3857);</span><br><span class="line"></span><br><span class="line">    v_startLine geometry;<span class="comment">--离起点最近的线  </span></span><br><span class="line">    v_endLine geometry;<span class="comment">--离终点最近的线  </span></span><br><span class="line">      </span><br><span class="line">    v_startTarget integer;<span class="comment">--距离起点最近线的终点  </span></span><br><span class="line">    v_endSource integer;<span class="comment">--距离终点最近线的起点  </span></span><br><span class="line">  </span><br><span class="line">    v_statpoint geometry;<span class="comment">--在v_startLine上距离起点最近的点  </span></span><br><span class="line">    v_endpoint geometry;<span class="comment">--在v_endLine上距离终点最近的点  </span></span><br><span class="line">      </span><br><span class="line">    v_res geometry;<span class="comment">--最短路径分析结果  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    v_perStart float;<span class="comment">--v_statpoint在v_res上的百分比  </span></span><br><span class="line">    v_perEnd float;<span class="comment">--v_endpoint在v_res上的百分比  </span></span><br><span class="line">  </span><br><span class="line">    v_shPath geometry;<span class="comment">--最终结果</span></span><br><span class="line">    tempnode float;	</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">--查询离起点最近的线  </span></span><br><span class="line">    <span class="keyword">select</span> geom, target</span><br><span class="line">	<span class="keyword">from</span> road</span><br><span class="line">	<span class="keyword">where</span>  ST_DWithin(geom, v_point1, <span class="number">3</span>) </span><br><span class="line">	<span class="keyword">order</span> <span class="keyword">by</span> ST_Distance(geom, v_point1) <span class="keyword">limit</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">into</span> v_startLine ,v_startTarget;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">--查询离终点最近的线  </span></span><br><span class="line">    <span class="keyword">select</span> geom, <span class="keyword">source</span></span><br><span class="line">	<span class="keyword">from</span> road </span><br><span class="line">	<span class="keyword">where</span> ST_DWithin(geom, v_point2, <span class="number">3</span>) </span><br><span class="line">	<span class="keyword">order</span> <span class="keyword">by</span> ST_Distance(geom, v_point2)  <span class="keyword">limit</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">into</span> v_endLine,v_endSource;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">--如果没找到最近的线，就返回null  </span></span><br><span class="line">    if (v_startLine is null) or (v_endLine is null) then  </span><br><span class="line">        return;  </span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span> ;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">select</span>  ST_ClosestPoint(v_startLine, v_point1) <span class="keyword">into</span> v_statpoint;  </span><br><span class="line">    <span class="keyword">select</span>  ST_ClosestPoint(v_endLine, v_point2) <span class="keyword">into</span> v_endpoint;  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">--最短路径  </span></span><br><span class="line">    <span class="keyword">execute</span> <span class="string">'SELECT st_linemerge(st_union(b.geom)) '</span> || </span><br><span class="line">    <span class="string">'FROM pgr_kdijkstraPath(  </span></span><br><span class="line"><span class="string">    ''SELECT gid as id, source, target, cost FROM road '','</span>  </span><br><span class="line">    ||v_startTarget || <span class="string">', '</span> ||<span class="string">'array['</span>||v_endSource||<span class="string">'] , false, false  </span></span><br><span class="line"><span class="string">    ) a, '</span>  </span><br><span class="line">    || tbl || <span class="string">' b  </span></span><br><span class="line"><span class="string">    WHERE a.id3=b.gid  </span></span><br><span class="line"><span class="string">    GROUP by id1  </span></span><br><span class="line"><span class="string">    ORDER by id1'</span> <span class="keyword">into</span> v_res ;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">--如果找不到最短路径，就返回null  </span></span><br><span class="line">    <span class="comment">--if(v_res is null) then  </span></span><br><span class="line">    <span class="comment">--    return null;  </span></span><br><span class="line">    <span class="comment">--end if;  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">--将v_res,v_startLine,v_endLine进行拼接  </span></span><br><span class="line">    <span class="keyword">select</span>  st_linemerge(ST_Union(<span class="built_in">array</span>[v_res,v_startLine,v_endLine])) <span class="keyword">into</span> v_res;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">select</span>  ST_LineLocatePoint(v_res, v_statpoint) <span class="keyword">into</span> v_perStart;  </span><br><span class="line">    <span class="keyword">select</span>  ST_LineLocatePoint(v_res, v_endpoint) <span class="keyword">into</span> v_perEnd;  </span><br><span class="line">	</span><br><span class="line">	if(v_perStart &gt; v_perEnd) then  </span><br><span class="line">        tempnode =  v_perStart;</span><br><span class="line">		v_perStart = v_perEnd;</span><br><span class="line">		v_perEnd = tempnode;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">--截取v_res  </span></span><br><span class="line">    <span class="keyword">SELECT</span> ST_LineSubString(v_res,v_perStart, v_perEnd) <span class="keyword">into</span> v_shPath;  </span><br><span class="line">       </span><br><span class="line">    RETURN QUERY <span class="keyword">SELECT</span> st_transform(v_shPath, <span class="number">4326</span>), st_length(v_shPath);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">$<span class="keyword">BODY</span>$</span><br><span class="line">  <span class="keyword">LANGUAGE</span> plpgsql VOLATILE</span><br><span class="line">  <span class="keyword">COST</span> <span class="number">100</span></span><br><span class="line">  <span class="keyword">ROWS</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><blockquote><p>修改的地方：</p><ol><li>固定了要查询的表。</li><li>将结果转换为 WGS84 坐标系。</li><li>在返回路径的同时返回了整个路径的长度。</li></ol></blockquote><h3 id="Python-调用函数的编写"><a href="#Python-调用函数的编写" class="headerlink" title="Python 调用函数的编写"></a>Python 调用函数的编写</h3><p>与之前类似，Python 调用函数的实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPaths</span><span class="params">(self, s1: State, s2: State)</span>:</span></span><br><span class="line">    <span class="string">''' 获取两个状态之间的路径</span></span><br><span class="line"><span class="string">    利用ArcPy获取路网上两点之间的最短路径</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 创建要素</span></span><br><span class="line">    <span class="keyword">if</span> s1.link_id == s2.link_id:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    cur = self.conn.cursor() <span class="comment"># type: psycopg2.extensions.cursor</span></span><br><span class="line">    cur.execute(<span class="string">"SELECT * FROM PIF_GetPathBetweenPoints(%s, %s, %s, %s)"</span>,</span><br><span class="line">                (s1.gps_pos.lng, s1.gps_pos.lat, s2.gps_pos.lng, s2.gps_pos.lat))</span><br><span class="line">    (linestring, cost) = cur.fetchone()  <span class="comment"># type: LineString</span></span><br><span class="line">    path = [((p1.x, p1.y), (p2.x, p2.y))</span><br><span class="line">            <span class="keyword">for</span> (p1, p2) <span class="keyword">in</span> zip(linestring[<span class="number">1</span>:<span class="number">-2</span>], linestring[<span class="number">2</span>:<span class="number">-1</span>])]</span><br><span class="line">    <span class="keyword">del</span> cur</span><br><span class="line">    <span class="keyword">return</span> [(s1, [s1.link_id] + path + [s2.link_id], s2, cost)]</span><br></pre></td></tr></table></figure><h2 id="路径结果后处理"><a href="#路径结果后处理" class="headerlink" title="路径结果后处理"></a>路径结果后处理</h2><p>在 PIF 核心库中，对两个车辆状态 $ x_i^{t} \in \mathbf{x}^{t} ,x_j^{t+1} \in \mathbf{x}^{t+1} $ 中间的路径 $ p_i $ 有要求。即 $ x_i^{t} $ 所在的路段的 ID 和 $x_j^{t+1}$ 所在路段的 ID 分别和 $ p_i $ 第一个路段的 ID 和 最后一个路段的 ID 相同。在不直接使用路段的 ID 作为最短路径搜索的返回值时，我们需要做一些处理。</p><blockquote><p>产生这个问题原因，是 PIF 库的示例代码中，采用 $ ((x_S, y_S), (x_T, y_T)) $ 来表示 $ x_i^{t} $ 所在的路段 ID。若记获取某个状态值所在路段的 ID 的函数是 $ \mathbf{id}(x) $，则要求 $ \mathbf{id}(x_i^{t}) = \overrightarrow{ST} = (p_i)_1 $，$ S, T $ 是路段的起点和终点。同理，$ \mathbf{id}(x_i^{t}) = \overrightarrow{ST} = (p_i)_{-1} $（$(p_i)_{-1}$ 表示最后一个搜索到的路径的最后一个路段）。</p></blockquote><p>对于起始状态，理论上共有 6 种可能。如下图所示。记起始状态点为 $X$，其可能的 6 种情况分别为 $ \left\lbrace x_1, x_2, \cdots, x_6 \right\rbrace $，其所在路段 $ \mathbf{l} = \overrightarrow{ST}$ 起点为 $S$，终点为 $T$，匹配到的整个路径为 $ P $。记符号 $ \lnot \mathbf{L} = \overrightarrow{TS} $。</p><img src="/科研工作/implementation-pif/start-state-process.png" title="起始状态的处理"><p>对于每个 $ X \in \left\lbrace x_1, x_2, \cdots, x_6 \right\rbrace $</p><ol><li>$ X = x_1 \neq S \neq T \wedge T = P_2 $ ：这是最一般的情况。只需令 $ P = \left\lbrace S \right \rbrace \cup P $ 即可。</li><li>$ X = S \wedge T = P_2 $ ：此种情况无需处理。</li><li>$ X = T \wedge S \neq P_2 $ ：令 $ P = \left\lbrace S \right \rbrace \cup P $。</li><li>$ X = x_1 \neq S \neq T \wedge S = P_2 $ ：令 $ \mathbf{id}(X) = \lnot \mathbf{l} $。</li><li>$ X = S \wedge T \neq P_2 $ ：令 $ P = \left\lbrace T \right \rbrace \cup P $，且 $ \mathbf{id}(X) = \lnot \mathbf{l} $。</li><li>$ X = T \wedge S = P_2 $ ：令 $ \mathbf{id}(X) = \lnot \mathbf{l} $。</li></ol><p>对于结束状态，可能的情况如下图。</p><img src="/科研工作/implementation-pif/end-state-process.png"><p>处理方法可与上同理。</p><blockquote><p>由于 pgRouting 的问题，好像会给求得的路径按照坐标大小排个序？我目前遇到过一次，因此，在进行上述处理之前，判断一下，起始状态和结束状态的坐标值是不是分别和路径的第一个点和最后一个点相同，如果不是，把路径反过来。</p></blockquote><blockquote><p>在理论上，上述 6 种情况是合理的。但是在实际运行过程中，竟然产生了 $$ X = x_1 \neq S \neq T \wedge T = P_2 \wedge S = P_2 $$ 的情况，因此还需要做一个处理。如果上述 6 种情况都不满足，视为没找到路径。</p></blockquote><h1 id="利用-ArcPy-实现调用-PIF-算法"><a href="#利用-ArcPy-实现调用-PIF-算法" class="headerlink" title="利用 ArcPy 实现调用 PIF 算法"></a>利用 ArcPy 实现调用 PIF 算法</h1><div class="post-announce">感谢您的阅读，本文由 <a href="http://hpdell.github.io">HPDell 的个人博客</a> 版权所有。如若转载，请注明出处：HPDell 的个人博客（<a href="http://hpdell.github.io/科研工作/implementation-pif/">http://hpdell.github.io/科研工作/implementation-pif/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/Git/gitweb/" title="GitWeb 的安装和配置"><i class="iconfont icon-prev"></i>GitWeb 的安装和配置</a></div><div class="post__prev post__prev--right"><a href="/网页开发/vue-jqm-note/" title="Vue 与 jQuery Mobile 混用">Vue 与 jQuery Mobile 混用<i class="iconfont icon-next"></i></a></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">HPDell 的博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/随笔/">随笔</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/网页开发/">网页开发</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/科研工作/">科研工作</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/爬虫/">爬虫</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/博客相关/">博客相关</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/WPF/">WPF</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Python/">Python</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/LaTeX/">LaTeX</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Git/">Git</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/uncategorized/english-postgraduates-subtitles/" title="武汉大学《硕士英语》课视听文件字幕"><div class="item__cover"><img src="/assets/img/header_cover.jpg" alt="武汉大学《硕士英语》课视听文件字幕"></div><div class="item__info"><h3 class="item__title">武汉大学《硕士英语》课视听文件字幕</h3><span class="item__text">2019-01-12</span></div></a></li><li class="latest-post-item"><a href="/LaTeX/latex-travis/" title="利用 Travis-CI 持续集成 LaTeX 文档"><div class="item__cover"><img src="/assets/img/header_cover.jpg" alt="利用 Travis-CI 持续集成 LaTeX 文档"></div><div class="item__info"><h3 class="item__title">利用 Travis-CI 持续集成 LaTeX 文档</h3><span class="item__text">2018-11-30</span></div></a></li><li class="latest-post-item"><a href="/随笔/Harry-Potter-Prisoner-of-Azkaban/" title="开个全局视角再看《哈利·波特》——阿兹卡班的囚徒"><div class="item__cover"><img src="/assets/img/header_cover.jpg" alt="开个全局视角再看《哈利·波特》——阿兹卡班的囚徒"></div><div class="item__info"><h3 class="item__title">开个全局视角再看《哈利·波特》——阿兹卡班的囚徒</h3><span class="item__text">2018-11-03</span></div></a></li><li class="latest-post-item"><a href="/uncategorized/wsl-xfce/" title="在 Windows 10 Linux 子系统中安装 xfce 桌面"><div class="item__cover"><img src="/assets/img/header_cover.jpg" alt="在 Windows 10 Linux 子系统中安装 xfce 桌面"></div><div class="item__info"><h3 class="item__title">在 Windows 10 Linux 子系统中安装 xfce 桌面</h3><span class="item__text">2018-10-20</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Apache-POI/">Apache POI</a></li><li class="tag-item"><a class="tag-link" href="/tags/Edge/">Edge</a></li><li class="tag-item"><a class="tag-link" href="/tags/Git/">Git</a></li><li class="tag-item"><a class="tag-link" href="/tags/Gitment/">Gitment</a></li><li class="tag-item"><a class="tag-link" href="/tags/ListBox/">ListBox</a></li><li class="tag-item"><a class="tag-link" href="/tags/ListView/">ListView</a></li><li class="tag-item"><a class="tag-link" href="/tags/Python/">Python</a></li><li class="tag-item"><a class="tag-link" href="/tags/TypeScript/">TypeScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/Vue/">Vue</a></li><li class="tag-item"><a class="tag-link" href="/tags/WPF/">WPF</a></li><li class="tag-item"><a class="tag-link" href="/tags/XAML/">XAML</a></li><li class="tag-item"><a class="tag-link" href="/tags/cs/">cs</a></li><li class="tag-item"><a class="tag-link" href="/tags/jQuery-Mobile/">jQuery Mobile</a></li><li class="tag-item"><a class="tag-link" href="/tags/latex/">latex</a></li><li class="tag-item"><a class="tag-link" href="/tags/travis/">travis</a></li><li class="tag-item"><a class="tag-link" href="/tags/信息安全/">信息安全</a></li><li class="tag-item"><a class="tag-link" href="/tags/哈利波特/">哈利波特</a></li><li class="tag-item"><a class="tag-link" href="/tags/影评/">影评</a></li><li class="tag-item"><a class="tag-link" href="/tags/爬虫/">爬虫</a></li><li class="tag-item"><a class="tag-link" href="/tags/路网速度/">路网速度</a></li></ul></div><div class="sidebar__block__sticky"><h3 class="block__title">目录</h3><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PIF-的数学原理"><span class="toc-text">PIF 的数学原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PIF-的接口调用"><span class="toc-text">PIF 的接口调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#利用-pgRouting-实现调用-PIF-算法"><span class="toc-text">利用 pgRouting 实现调用 PIF 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用到的-Python-包"><span class="toc-text">使用到的 Python 包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#准备路网数据"><span class="toc-text">准备路网数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据导入"><span class="toc-text">数据导入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑关系建立"><span class="toc-text">拓扑关系建立</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算两点间距离"><span class="toc-text">计算两点间距离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取每个-GPS-点对应的状态值"><span class="toc-text">获取每个 GPS 点对应的状态值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#需要使用到的-PostGIS-函数"><span class="toc-text">需要使用到的 PostGIS 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编写-PostgreSQL-函数"><span class="toc-text">编写 PostgreSQL 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-函数的编写"><span class="toc-text">Python 函数的编写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取状态值间的最短路径"><span class="toc-text">获取状态值间的最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库函数的编写"><span class="toc-text">数据库函数的编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-调用函数的编写"><span class="toc-text">Python 调用函数的编写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#路径结果后处理"><span class="toc-text">路径结果后处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#利用-ArcPy-实现调用-PIF-算法"><span class="toc-text">利用 ArcPy 实现调用 PIF 算法</span></a></li></ol></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">Geography Weighted Modelling Lab of Wuhan University.</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Wuhan University, Luoyu Road, Wuhan, Hubei, China.</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>BinbinLu@whu.edu.cn</span></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["路网速度"],gitalk=new Gitalk({clientID:"47d3a0c03f3c07172ecc",clientSecret:"8e0da02c5e757c77b93627a7e380e43a248d001c",repo:"HPDell.github.io",owner:"HPDell",admin:["HPDell"],labels:tags,id:new Date(1515086997e3).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>